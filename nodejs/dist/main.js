/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/minimist/index.js":
/*!****************************************!*\
  !*** ./node_modules/minimist/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function (args, opts) {\n    if (!opts) opts = {};\n    \n    var flags = { bools : {}, strings : {}, unknownFn: null };\n\n    if (typeof opts['unknown'] === 'function') {\n        flags.unknownFn = opts['unknown'];\n    }\n\n    if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {\n      flags.allBools = true;\n    } else {\n      [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {\n          flags.bools[key] = true;\n      });\n    }\n    \n    var aliases = {};\n    Object.keys(opts.alias || {}).forEach(function (key) {\n        aliases[key] = [].concat(opts.alias[key]);\n        aliases[key].forEach(function (x) {\n            aliases[x] = [key].concat(aliases[key].filter(function (y) {\n                return x !== y;\n            }));\n        });\n    });\n\n    [].concat(opts.string).filter(Boolean).forEach(function (key) {\n        flags.strings[key] = true;\n        if (aliases[key]) {\n            flags.strings[aliases[key]] = true;\n        }\n     });\n\n    var defaults = opts['default'] || {};\n    \n    var argv = { _ : [] };\n    Object.keys(flags.bools).forEach(function (key) {\n        setArg(key, defaults[key] === undefined ? false : defaults[key]);\n    });\n    \n    var notFlags = [];\n\n    if (args.indexOf('--') !== -1) {\n        notFlags = args.slice(args.indexOf('--')+1);\n        args = args.slice(0, args.indexOf('--'));\n    }\n\n    function argDefined(key, arg) {\n        return (flags.allBools && /^--[^=]+$/.test(arg)) ||\n            flags.strings[key] || flags.bools[key] || aliases[key];\n    }\n\n    function setArg (key, val, arg) {\n        if (arg && flags.unknownFn && !argDefined(key, arg)) {\n            if (flags.unknownFn(arg) === false) return;\n        }\n\n        var value = !flags.strings[key] && isNumber(val)\n            ? Number(val) : val\n        ;\n        setKey(argv, key.split('.'), value);\n        \n        (aliases[key] || []).forEach(function (x) {\n            setKey(argv, x.split('.'), value);\n        });\n    }\n\n    function setKey (obj, keys, value) {\n        var o = obj;\n        keys.slice(0,-1).forEach(function (key) {\n            if (o[key] === undefined) o[key] = {};\n            o = o[key];\n        });\n\n        var key = keys[keys.length - 1];\n        if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {\n            o[key] = value;\n        }\n        else if (Array.isArray(o[key])) {\n            o[key].push(value);\n        }\n        else {\n            o[key] = [ o[key], value ];\n        }\n    }\n    \n    function aliasIsBoolean(key) {\n      return aliases[key].some(function (x) {\n          return flags.bools[x];\n      });\n    }\n\n    for (var i = 0; i < args.length; i++) {\n        var arg = args[i];\n        \n        if (/^--.+=/.test(arg)) {\n            // Using [\\s\\S] instead of . because js doesn't support the\n            // 'dotall' regex modifier. See:\n            // http://stackoverflow.com/a/1068308/13216\n            var m = arg.match(/^--([^=]+)=([\\s\\S]*)$/);\n            var key = m[1];\n            var value = m[2];\n            if (flags.bools[key]) {\n                value = value !== 'false';\n            }\n            setArg(key, value, arg);\n        }\n        else if (/^--no-.+/.test(arg)) {\n            var key = arg.match(/^--no-(.+)/)[1];\n            setArg(key, false, arg);\n        }\n        else if (/^--.+/.test(arg)) {\n            var key = arg.match(/^--(.+)/)[1];\n            var next = args[i + 1];\n            if (next !== undefined && !/^-/.test(next)\n            && !flags.bools[key]\n            && !flags.allBools\n            && (aliases[key] ? !aliasIsBoolean(key) : true)) {\n                setArg(key, next, arg);\n                i++;\n            }\n            else if (/^(true|false)$/.test(next)) {\n                setArg(key, next === 'true', arg);\n                i++;\n            }\n            else {\n                setArg(key, flags.strings[key] ? '' : true, arg);\n            }\n        }\n        else if (/^-[^-]+/.test(arg)) {\n            var letters = arg.slice(1,-1).split('');\n            \n            var broken = false;\n            for (var j = 0; j < letters.length; j++) {\n                var next = arg.slice(j+2);\n                \n                if (next === '-') {\n                    setArg(letters[j], next, arg)\n                    continue;\n                }\n                \n                if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {\n                    setArg(letters[j], next.split('=')[1], arg);\n                    broken = true;\n                    break;\n                }\n                \n                if (/[A-Za-z]/.test(letters[j])\n                && /-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) {\n                    setArg(letters[j], next, arg);\n                    broken = true;\n                    break;\n                }\n                \n                if (letters[j+1] && letters[j+1].match(/\\W/)) {\n                    setArg(letters[j], arg.slice(j+2), arg);\n                    broken = true;\n                    break;\n                }\n                else {\n                    setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);\n                }\n            }\n            \n            var key = arg.slice(-1)[0];\n            if (!broken && key !== '-') {\n                if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])\n                && !flags.bools[key]\n                && (aliases[key] ? !aliasIsBoolean(key) : true)) {\n                    setArg(key, args[i+1], arg);\n                    i++;\n                }\n                else if (args[i+1] && /true|false/.test(args[i+1])) {\n                    setArg(key, args[i+1] === 'true', arg);\n                    i++;\n                }\n                else {\n                    setArg(key, flags.strings[key] ? '' : true, arg);\n                }\n            }\n        }\n        else {\n            if (!flags.unknownFn || flags.unknownFn(arg) !== false) {\n                argv._.push(\n                    flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)\n                );\n            }\n            if (opts.stopEarly) {\n                argv._.push.apply(argv._, args.slice(i + 1));\n                break;\n            }\n        }\n    }\n    \n    Object.keys(defaults).forEach(function (key) {\n        if (!hasKey(argv, key.split('.'))) {\n            setKey(argv, key.split('.'), defaults[key]);\n            \n            (aliases[key] || []).forEach(function (x) {\n                setKey(argv, x.split('.'), defaults[key]);\n            });\n        }\n    });\n    \n    if (opts['--']) {\n        argv['--'] = new Array();\n        notFlags.forEach(function(key) {\n            argv['--'].push(key);\n        });\n    }\n    else {\n        notFlags.forEach(function(key) {\n            argv._.push(key);\n        });\n    }\n\n    return argv;\n};\n\nfunction hasKey (obj, keys) {\n    var o = obj;\n    keys.slice(0,-1).forEach(function (key) {\n        o = (o[key] || {});\n    });\n\n    var key = keys[keys.length - 1];\n    return key in o;\n}\n\nfunction isNumber (x) {\n    if (typeof x === 'number') return true;\n    if (/^0x[0-9a-f]+$/i.test(x)) return true;\n    return /^[-+]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWluaW1pc3QvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWluaW1pc3QvaW5kZXguanM/ZjJmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmdzLCBvcHRzKSB7XG4gICAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gICAgXG4gICAgdmFyIGZsYWdzID0geyBib29scyA6IHt9LCBzdHJpbmdzIDoge30sIHVua25vd25GbjogbnVsbCB9O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRzWyd1bmtub3duJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZmxhZ3MudW5rbm93bkZuID0gb3B0c1sndW5rbm93biddO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0c1snYm9vbGVhbiddID09PSAnYm9vbGVhbicgJiYgb3B0c1snYm9vbGVhbiddKSB7XG4gICAgICBmbGFncy5hbGxCb29scyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIFtdLmNvbmNhdChvcHRzWydib29sZWFuJ10pLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBmbGFncy5ib29sc1trZXldID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKG9wdHMuYWxpYXMgfHwge30pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBhbGlhc2VzW2tleV0gPSBbXS5jb25jYXQob3B0cy5hbGlhc1trZXldKTtcbiAgICAgICAgYWxpYXNlc1trZXldLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIGFsaWFzZXNbeF0gPSBba2V5XS5jb25jYXQoYWxpYXNlc1trZXldLmZpbHRlcihmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4ICE9PSB5O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIFtdLmNvbmNhdChvcHRzLnN0cmluZykuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBmbGFncy5zdHJpbmdzW2tleV0gPSB0cnVlO1xuICAgICAgICBpZiAoYWxpYXNlc1trZXldKSB7XG4gICAgICAgICAgICBmbGFncy5zdHJpbmdzW2FsaWFzZXNba2V5XV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgIH0pO1xuXG4gICAgdmFyIGRlZmF1bHRzID0gb3B0c1snZGVmYXVsdCddIHx8IHt9O1xuICAgIFxuICAgIHZhciBhcmd2ID0geyBfIDogW10gfTtcbiAgICBPYmplY3Qua2V5cyhmbGFncy5ib29scykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHNldEFyZyhrZXksIGRlZmF1bHRzW2tleV0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogZGVmYXVsdHNba2V5XSk7XG4gICAgfSk7XG4gICAgXG4gICAgdmFyIG5vdEZsYWdzID0gW107XG5cbiAgICBpZiAoYXJncy5pbmRleE9mKCctLScpICE9PSAtMSkge1xuICAgICAgICBub3RGbGFncyA9IGFyZ3Muc2xpY2UoYXJncy5pbmRleE9mKCctLScpKzEpO1xuICAgICAgICBhcmdzID0gYXJncy5zbGljZSgwLCBhcmdzLmluZGV4T2YoJy0tJykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFyZ0RlZmluZWQoa2V5LCBhcmcpIHtcbiAgICAgICAgcmV0dXJuIChmbGFncy5hbGxCb29scyAmJiAvXi0tW149XSskLy50ZXN0KGFyZykpIHx8XG4gICAgICAgICAgICBmbGFncy5zdHJpbmdzW2tleV0gfHwgZmxhZ3MuYm9vbHNba2V5XSB8fCBhbGlhc2VzW2tleV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0QXJnIChrZXksIHZhbCwgYXJnKSB7XG4gICAgICAgIGlmIChhcmcgJiYgZmxhZ3MudW5rbm93bkZuICYmICFhcmdEZWZpbmVkKGtleSwgYXJnKSkge1xuICAgICAgICAgICAgaWYgKGZsYWdzLnVua25vd25GbihhcmcpID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlID0gIWZsYWdzLnN0cmluZ3Nba2V5XSAmJiBpc051bWJlcih2YWwpXG4gICAgICAgICAgICA/IE51bWJlcih2YWwpIDogdmFsXG4gICAgICAgIDtcbiAgICAgICAgc2V0S2V5KGFyZ3YsIGtleS5zcGxpdCgnLicpLCB2YWx1ZSk7XG4gICAgICAgIFxuICAgICAgICAoYWxpYXNlc1trZXldIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICBzZXRLZXkoYXJndiwgeC5zcGxpdCgnLicpLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEtleSAob2JqLCBrZXlzLCB2YWx1ZSkge1xuICAgICAgICB2YXIgbyA9IG9iajtcbiAgICAgICAga2V5cy5zbGljZSgwLC0xKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChvW2tleV0gPT09IHVuZGVmaW5lZCkgb1trZXldID0ge307XG4gICAgICAgICAgICBvID0gb1trZXldO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIga2V5ID0ga2V5c1trZXlzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAob1trZXldID09PSB1bmRlZmluZWQgfHwgZmxhZ3MuYm9vbHNba2V5XSB8fCB0eXBlb2Ygb1trZXldID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIG9ba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob1trZXldKSkge1xuICAgICAgICAgICAgb1trZXldLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb1trZXldID0gWyBvW2tleV0sIHZhbHVlIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gYWxpYXNJc0Jvb2xlYW4oa2V5KSB7XG4gICAgICByZXR1cm4gYWxpYXNlc1trZXldLnNvbWUoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4gZmxhZ3MuYm9vbHNbeF07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ3NbaV07XG4gICAgICAgIFxuICAgICAgICBpZiAoL14tLS4rPS8udGVzdChhcmcpKSB7XG4gICAgICAgICAgICAvLyBVc2luZyBbXFxzXFxTXSBpbnN0ZWFkIG9mIC4gYmVjYXVzZSBqcyBkb2Vzbid0IHN1cHBvcnQgdGhlXG4gICAgICAgICAgICAvLyAnZG90YWxsJyByZWdleCBtb2RpZmllci4gU2VlOlxuICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTA2ODMwOC8xMzIxNlxuICAgICAgICAgICAgdmFyIG0gPSBhcmcubWF0Y2goL14tLShbXj1dKyk9KFtcXHNcXFNdKikkLyk7XG4gICAgICAgICAgICB2YXIga2V5ID0gbVsxXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG1bMl07XG4gICAgICAgICAgICBpZiAoZmxhZ3MuYm9vbHNba2V5XSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgIT09ICdmYWxzZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRBcmcoa2V5LCB2YWx1ZSwgYXJnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXi0tbm8tLisvLnRlc3QoYXJnKSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGFyZy5tYXRjaCgvXi0tbm8tKC4rKS8pWzFdO1xuICAgICAgICAgICAgc2V0QXJnKGtleSwgZmFsc2UsIGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL14tLS4rLy50ZXN0KGFyZykpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBhcmcubWF0Y2goL14tLSguKykvKVsxXTtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gYXJnc1tpICsgMV07XG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gdW5kZWZpbmVkICYmICEvXi0vLnRlc3QobmV4dClcbiAgICAgICAgICAgICYmICFmbGFncy5ib29sc1trZXldXG4gICAgICAgICAgICAmJiAhZmxhZ3MuYWxsQm9vbHNcbiAgICAgICAgICAgICYmIChhbGlhc2VzW2tleV0gPyAhYWxpYXNJc0Jvb2xlYW4oa2V5KSA6IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgbmV4dCwgYXJnKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgvXih0cnVlfGZhbHNlKSQvLnRlc3QobmV4dCkpIHtcbiAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBuZXh0ID09PSAndHJ1ZScsIGFyZyk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgZmxhZ3Muc3RyaW5nc1trZXldID8gJycgOiB0cnVlLCBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9eLVteLV0rLy50ZXN0KGFyZykpIHtcbiAgICAgICAgICAgIHZhciBsZXR0ZXJzID0gYXJnLnNsaWNlKDEsLTEpLnNwbGl0KCcnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGJyb2tlbiA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZXR0ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSBhcmcuc2xpY2UoaisyKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEFyZyhsZXR0ZXJzW2pdLCBuZXh0LCBhcmcpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoL1tBLVphLXpdLy50ZXN0KGxldHRlcnNbal0pICYmIC89Ly50ZXN0KG5leHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEFyZyhsZXR0ZXJzW2pdLCBuZXh0LnNwbGl0KCc9JylbMV0sIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIGJyb2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoL1tBLVphLXpdLy50ZXN0KGxldHRlcnNbal0pXG4gICAgICAgICAgICAgICAgJiYgLy0/XFxkKyhcXC5cXGQqKT8oZS0/XFxkKyk/JC8udGVzdChuZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRBcmcobGV0dGVyc1tqXSwgbmV4dCwgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChsZXR0ZXJzW2orMV0gJiYgbGV0dGVyc1tqKzFdLm1hdGNoKC9cXFcvKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRBcmcobGV0dGVyc1tqXSwgYXJnLnNsaWNlKGorMiksIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIGJyb2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QXJnKGxldHRlcnNbal0sIGZsYWdzLnN0cmluZ3NbbGV0dGVyc1tqXV0gPyAnJyA6IHRydWUsIGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIga2V5ID0gYXJnLnNsaWNlKC0xKVswXTtcbiAgICAgICAgICAgIGlmICghYnJva2VuICYmIGtleSAhPT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3NbaSsxXSAmJiAhL14oLXwtLSlbXi1dLy50ZXN0KGFyZ3NbaSsxXSlcbiAgICAgICAgICAgICAgICAmJiAhZmxhZ3MuYm9vbHNba2V5XVxuICAgICAgICAgICAgICAgICYmIChhbGlhc2VzW2tleV0gPyAhYWxpYXNJc0Jvb2xlYW4oa2V5KSA6IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEFyZyhrZXksIGFyZ3NbaSsxXSwgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmdzW2krMV0gJiYgL3RydWV8ZmFsc2UvLnRlc3QoYXJnc1tpKzFdKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBhcmdzW2krMV0gPT09ICd0cnVlJywgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgZmxhZ3Muc3RyaW5nc1trZXldID8gJycgOiB0cnVlLCBhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghZmxhZ3MudW5rbm93bkZuIHx8IGZsYWdzLnVua25vd25GbihhcmcpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGFyZ3YuXy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICBmbGFncy5zdHJpbmdzWydfJ10gfHwgIWlzTnVtYmVyKGFyZykgPyBhcmcgOiBOdW1iZXIoYXJnKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5zdG9wRWFybHkpIHtcbiAgICAgICAgICAgICAgICBhcmd2Ll8ucHVzaC5hcHBseShhcmd2Ll8sIGFyZ3Muc2xpY2UoaSArIDEpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBPYmplY3Qua2V5cyhkZWZhdWx0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghaGFzS2V5KGFyZ3YsIGtleS5zcGxpdCgnLicpKSkge1xuICAgICAgICAgICAgc2V0S2V5KGFyZ3YsIGtleS5zcGxpdCgnLicpLCBkZWZhdWx0c1trZXldKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgKGFsaWFzZXNba2V5XSB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHNldEtleShhcmd2LCB4LnNwbGl0KCcuJyksIGRlZmF1bHRzW2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBpZiAob3B0c1snLS0nXSkge1xuICAgICAgICBhcmd2WyctLSddID0gbmV3IEFycmF5KCk7XG4gICAgICAgIG5vdEZsYWdzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBhcmd2WyctLSddLnB1c2goa2V5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub3RGbGFncy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgYXJndi5fLnB1c2goa2V5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZ3Y7XG59O1xuXG5mdW5jdGlvbiBoYXNLZXkgKG9iaiwga2V5cykge1xuICAgIHZhciBvID0gb2JqO1xuICAgIGtleXMuc2xpY2UoMCwtMSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIG8gPSAob1trZXldIHx8IHt9KTtcbiAgICB9KTtcblxuICAgIHZhciBrZXkgPSBrZXlzW2tleXMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGtleSBpbiBvO1xufVxuXG5mdW5jdGlvbiBpc051bWJlciAoeCkge1xuICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHJldHVybiB0cnVlO1xuICAgIGlmICgvXjB4WzAtOWEtZl0rJC9pLnRlc3QoeCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiAvXlstK10/KD86XFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKShlWy0rXT9cXGQrKT8kLy50ZXN0KHgpO1xufVxuXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/minimist/index.js\n");

/***/ }),

/***/ "./node_modules/node-fetch/lib/index.mjs":
/*!***********************************************!*\
  !*** ./node_modules/node-fetch/lib/index.mjs ***!
  \***********************************************/
/*! exports provided: default, Headers, Request, Response, FetchError */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Headers\", function() { return Headers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Request\", function() { return Request; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Response\", function() { return Response; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FetchError\", function() { return FetchError; });\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! url */ \"url\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zlib */ \"zlib\");\n\r\n\r\n\r\n\r\n\r\n\r\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\r\n\r\n// fix for \"Readable\" isn't a named export issue\r\nconst Readable = stream__WEBPACK_IMPORTED_MODULE_0__.Readable;\r\n\r\nconst BUFFER = Symbol('buffer');\r\nconst TYPE = Symbol('type');\r\n\r\nclass Blob {\r\n\tconstructor() {\r\n\t\tthis[TYPE] = '';\r\n\r\n\t\tconst blobParts = arguments[0];\r\n\t\tconst options = arguments[1];\r\n\r\n\t\tconst buffers = [];\r\n\t\tlet size = 0;\r\n\r\n\t\tif (blobParts) {\r\n\t\t\tconst a = blobParts;\r\n\t\t\tconst length = Number(a.length);\r\n\t\t\tfor (let i = 0; i < length; i++) {\r\n\t\t\t\tconst element = a[i];\r\n\t\t\t\tlet buffer;\r\n\t\t\t\tif (element instanceof Buffer) {\r\n\t\t\t\t\tbuffer = element;\r\n\t\t\t\t} else if (ArrayBuffer.isView(element)) {\r\n\t\t\t\t\tbuffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\r\n\t\t\t\t} else if (element instanceof ArrayBuffer) {\r\n\t\t\t\t\tbuffer = Buffer.from(element);\r\n\t\t\t\t} else if (element instanceof Blob) {\r\n\t\t\t\t\tbuffer = element[BUFFER];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbuffer = Buffer.from(typeof element === 'string' ? element : String(element));\r\n\t\t\t\t}\r\n\t\t\t\tsize += buffer.length;\r\n\t\t\t\tbuffers.push(buffer);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis[BUFFER] = Buffer.concat(buffers);\r\n\r\n\t\tlet type = options && options.type !== undefined && String(options.type).toLowerCase();\r\n\t\tif (type && !/[^\\u0020-\\u007E]/.test(type)) {\r\n\t\t\tthis[TYPE] = type;\r\n\t\t}\r\n\t}\r\n\tget size() {\r\n\t\treturn this[BUFFER].length;\r\n\t}\r\n\tget type() {\r\n\t\treturn this[TYPE];\r\n\t}\r\n\ttext() {\r\n\t\treturn Promise.resolve(this[BUFFER].toString());\r\n\t}\r\n\tarrayBuffer() {\r\n\t\tconst buf = this[BUFFER];\r\n\t\tconst ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\r\n\t\treturn Promise.resolve(ab);\r\n\t}\r\n\tstream() {\r\n\t\tconst readable = new Readable();\r\n\t\treadable._read = function () {};\r\n\t\treadable.push(this[BUFFER]);\r\n\t\treadable.push(null);\r\n\t\treturn readable;\r\n\t}\r\n\ttoString() {\r\n\t\treturn '[object Blob]';\r\n\t}\r\n\tslice() {\r\n\t\tconst size = this.size;\r\n\r\n\t\tconst start = arguments[0];\r\n\t\tconst end = arguments[1];\r\n\t\tlet relativeStart, relativeEnd;\r\n\t\tif (start === undefined) {\r\n\t\t\trelativeStart = 0;\r\n\t\t} else if (start < 0) {\r\n\t\t\trelativeStart = Math.max(size + start, 0);\r\n\t\t} else {\r\n\t\t\trelativeStart = Math.min(start, size);\r\n\t\t}\r\n\t\tif (end === undefined) {\r\n\t\t\trelativeEnd = size;\r\n\t\t} else if (end < 0) {\r\n\t\t\trelativeEnd = Math.max(size + end, 0);\r\n\t\t} else {\r\n\t\t\trelativeEnd = Math.min(end, size);\r\n\t\t}\r\n\t\tconst span = Math.max(relativeEnd - relativeStart, 0);\r\n\r\n\t\tconst buffer = this[BUFFER];\r\n\t\tconst slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\r\n\t\tconst blob = new Blob([], { type: arguments[2] });\r\n\t\tblob[BUFFER] = slicedBuffer;\r\n\t\treturn blob;\r\n\t}\r\n}\r\n\r\nObject.defineProperties(Blob.prototype, {\r\n\tsize: { enumerable: true },\r\n\ttype: { enumerable: true },\r\n\tslice: { enumerable: true }\r\n});\r\n\r\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\r\n\tvalue: 'Blob',\r\n\twritable: false,\r\n\tenumerable: false,\r\n\tconfigurable: true\r\n});\r\n\r\n/**\r\n * fetch-error.js\r\n *\r\n * FetchError interface for operational errors\r\n */\r\n\r\n/**\r\n * Create FetchError instance\r\n *\r\n * @param   String      message      Error message for human\r\n * @param   String      type         Error type for machine\r\n * @param   String      systemError  For Node.js system error\r\n * @return  FetchError\r\n */\r\nfunction FetchError(message, type, systemError) {\r\n  Error.call(this, message);\r\n\r\n  this.message = message;\r\n  this.type = type;\r\n\r\n  // when err.type is `system`, err.code contains system error code\r\n  if (systemError) {\r\n    this.code = this.errno = systemError.code;\r\n  }\r\n\r\n  // hide custom error implementation details from end-users\r\n  Error.captureStackTrace(this, this.constructor);\r\n}\r\n\r\nFetchError.prototype = Object.create(Error.prototype);\r\nFetchError.prototype.constructor = FetchError;\r\nFetchError.prototype.name = 'FetchError';\r\n\r\nlet convert;\r\ntry {\r\n\tconvert = require('encoding').convert;\r\n} catch (e) {}\r\n\r\nconst INTERNALS = Symbol('Body internals');\r\n\r\n// fix an issue where \"PassThrough\" isn't a named export for node <10\r\nconst PassThrough = stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough;\r\n\r\n/**\r\n * Body mixin\r\n *\r\n * Ref: https://fetch.spec.whatwg.org/#body\r\n *\r\n * @param   Stream  body  Readable stream\r\n * @param   Object  opts  Response options\r\n * @return  Void\r\n */\r\nfunction Body(body) {\r\n\tvar _this = this;\r\n\r\n\tvar _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\r\n\t    _ref$size = _ref.size;\r\n\r\n\tlet size = _ref$size === undefined ? 0 : _ref$size;\r\n\tvar _ref$timeout = _ref.timeout;\r\n\tlet timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\r\n\r\n\tif (body == null) {\r\n\t\t// body is undefined or null\r\n\t\tbody = null;\r\n\t} else if (isURLSearchParams(body)) {\r\n\t\t// body is a URLSearchParams\r\n\t\tbody = Buffer.from(body.toString());\r\n\t} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\r\n\t\t// body is ArrayBuffer\r\n\t\tbody = Buffer.from(body);\r\n\t} else if (ArrayBuffer.isView(body)) {\r\n\t\t// body is ArrayBufferView\r\n\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\r\n\t} else if (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__) ; else {\r\n\t\t// none of the above\r\n\t\t// coerce to string then buffer\r\n\t\tbody = Buffer.from(String(body));\r\n\t}\r\n\tthis[INTERNALS] = {\r\n\t\tbody,\r\n\t\tdisturbed: false,\r\n\t\terror: null\r\n\t};\r\n\tthis.size = size;\r\n\tthis.timeout = timeout;\r\n\r\n\tif (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__) {\r\n\t\tbody.on('error', function (err) {\r\n\t\t\tconst error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);\r\n\t\t\t_this[INTERNALS].error = error;\r\n\t\t});\r\n\t}\r\n}\r\n\r\nBody.prototype = {\r\n\tget body() {\r\n\t\treturn this[INTERNALS].body;\r\n\t},\r\n\r\n\tget bodyUsed() {\r\n\t\treturn this[INTERNALS].disturbed;\r\n\t},\r\n\r\n\t/**\r\n  * Decode response as ArrayBuffer\r\n  *\r\n  * @return  Promise\r\n  */\r\n\tarrayBuffer() {\r\n\t\treturn consumeBody.call(this).then(function (buf) {\r\n\t\t\treturn buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\r\n\t\t});\r\n\t},\r\n\r\n\t/**\r\n  * Return raw response as Blob\r\n  *\r\n  * @return Promise\r\n  */\r\n\tblob() {\r\n\t\tlet ct = this.headers && this.headers.get('content-type') || '';\r\n\t\treturn consumeBody.call(this).then(function (buf) {\r\n\t\t\treturn Object.assign(\r\n\t\t\t// Prevent copying\r\n\t\t\tnew Blob([], {\r\n\t\t\t\ttype: ct.toLowerCase()\r\n\t\t\t}), {\r\n\t\t\t\t[BUFFER]: buf\r\n\t\t\t});\r\n\t\t});\r\n\t},\r\n\r\n\t/**\r\n  * Decode response as json\r\n  *\r\n  * @return  Promise\r\n  */\r\n\tjson() {\r\n\t\tvar _this2 = this;\r\n\r\n\t\treturn consumeBody.call(this).then(function (buffer) {\r\n\t\t\ttry {\r\n\t\t\t\treturn JSON.parse(buffer.toString());\r\n\t\t\t} catch (err) {\r\n\t\t\t\treturn Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\t/**\r\n  * Decode response as text\r\n  *\r\n  * @return  Promise\r\n  */\r\n\ttext() {\r\n\t\treturn consumeBody.call(this).then(function (buffer) {\r\n\t\t\treturn buffer.toString();\r\n\t\t});\r\n\t},\r\n\r\n\t/**\r\n  * Decode response as buffer (non-spec api)\r\n  *\r\n  * @return  Promise\r\n  */\r\n\tbuffer() {\r\n\t\treturn consumeBody.call(this);\r\n\t},\r\n\r\n\t/**\r\n  * Decode response as text, while automatically detecting the encoding and\r\n  * trying to decode to UTF-8 (non-spec api)\r\n  *\r\n  * @return  Promise\r\n  */\r\n\ttextConverted() {\r\n\t\tvar _this3 = this;\r\n\r\n\t\treturn consumeBody.call(this).then(function (buffer) {\r\n\t\t\treturn convertBody(buffer, _this3.headers);\r\n\t\t});\r\n\t}\r\n};\r\n\r\n// In browsers, all properties are enumerable.\r\nObject.defineProperties(Body.prototype, {\r\n\tbody: { enumerable: true },\r\n\tbodyUsed: { enumerable: true },\r\n\tarrayBuffer: { enumerable: true },\r\n\tblob: { enumerable: true },\r\n\tjson: { enumerable: true },\r\n\ttext: { enumerable: true }\r\n});\r\n\r\nBody.mixIn = function (proto) {\r\n\tfor (const name of Object.getOwnPropertyNames(Body.prototype)) {\r\n\t\t// istanbul ignore else: future proof\r\n\t\tif (!(name in proto)) {\r\n\t\t\tconst desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\r\n\t\t\tObject.defineProperty(proto, name, desc);\r\n\t\t}\r\n\t}\r\n};\r\n\r\n/**\r\n * Consume and convert an entire Body to a Buffer.\r\n *\r\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\r\n *\r\n * @return  Promise\r\n */\r\nfunction consumeBody() {\r\n\tvar _this4 = this;\r\n\r\n\tif (this[INTERNALS].disturbed) {\r\n\t\treturn Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));\r\n\t}\r\n\r\n\tthis[INTERNALS].disturbed = true;\r\n\r\n\tif (this[INTERNALS].error) {\r\n\t\treturn Body.Promise.reject(this[INTERNALS].error);\r\n\t}\r\n\r\n\tlet body = this.body;\r\n\r\n\t// body is null\r\n\tif (body === null) {\r\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\r\n\t}\r\n\r\n\t// body is blob\r\n\tif (isBlob(body)) {\r\n\t\tbody = body.stream();\r\n\t}\r\n\r\n\t// body is buffer\r\n\tif (Buffer.isBuffer(body)) {\r\n\t\treturn Body.Promise.resolve(body);\r\n\t}\r\n\r\n\t// istanbul ignore if: should never happen\r\n\tif (!(body instanceof stream__WEBPACK_IMPORTED_MODULE_0__)) {\r\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\r\n\t}\r\n\r\n\t// body is stream\r\n\t// get ready to actually consume the body\r\n\tlet accum = [];\r\n\tlet accumBytes = 0;\r\n\tlet abort = false;\r\n\r\n\treturn new Body.Promise(function (resolve, reject) {\r\n\t\tlet resTimeout;\r\n\r\n\t\t// allow timeout on slow response body\r\n\t\tif (_this4.timeout) {\r\n\t\t\tresTimeout = setTimeout(function () {\r\n\t\t\t\tabort = true;\r\n\t\t\t\treject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));\r\n\t\t\t}, _this4.timeout);\r\n\t\t}\r\n\r\n\t\t// handle stream errors\r\n\t\tbody.on('error', function (err) {\r\n\t\t\tif (err.name === 'AbortError') {\r\n\t\t\t\t// if the request was aborted, reject with this Error\r\n\t\t\t\tabort = true;\r\n\t\t\t\treject(err);\r\n\t\t\t} else {\r\n\t\t\t\t// other errors, such as incorrect content-encoding\r\n\t\t\t\treject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tbody.on('data', function (chunk) {\r\n\t\t\tif (abort || chunk === null) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (_this4.size && accumBytes + chunk.length > _this4.size) {\r\n\t\t\t\tabort = true;\r\n\t\t\t\treject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\taccumBytes += chunk.length;\r\n\t\t\taccum.push(chunk);\r\n\t\t});\r\n\r\n\t\tbody.on('end', function () {\r\n\t\t\tif (abort) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tclearTimeout(resTimeout);\r\n\r\n\t\t\ttry {\r\n\t\t\t\tresolve(Buffer.concat(accum, accumBytes));\r\n\t\t\t} catch (err) {\r\n\t\t\t\t// handle streams that have accumulated too much data (issue #414)\r\n\t\t\t\treject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));\r\n\t\t\t}\r\n\t\t});\r\n\t});\r\n}\r\n\r\n/**\r\n * Detect buffer encoding and convert to target encoding\r\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\r\n *\r\n * @param   Buffer  buffer    Incoming buffer\r\n * @param   String  encoding  Target encoding\r\n * @return  String\r\n */\r\nfunction convertBody(buffer, headers) {\r\n\tif (typeof convert !== 'function') {\r\n\t\tthrow new Error('The package `encoding` must be installed to use the textConverted() function');\r\n\t}\r\n\r\n\tconst ct = headers.get('content-type');\r\n\tlet charset = 'utf-8';\r\n\tlet res, str;\r\n\r\n\t// header\r\n\tif (ct) {\r\n\t\tres = /charset=([^;]*)/i.exec(ct);\r\n\t}\r\n\r\n\t// no charset in content type, peek at response body for at most 1024 bytes\r\n\tstr = buffer.slice(0, 1024).toString();\r\n\r\n\t// html5\r\n\tif (!res && str) {\r\n\t\tres = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\r\n\t}\r\n\r\n\t// html4\r\n\tif (!res && str) {\r\n\t\tres = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\r\n\r\n\t\tif (res) {\r\n\t\t\tres = /charset=(.*)/i.exec(res.pop());\r\n\t\t}\r\n\t}\r\n\r\n\t// xml\r\n\tif (!res && str) {\r\n\t\tres = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\r\n\t}\r\n\r\n\t// found charset\r\n\tif (res) {\r\n\t\tcharset = res.pop();\r\n\r\n\t\t// prevent decode issues when sites use incorrect encoding\r\n\t\t// ref: https://hsivonen.fi/encoding-menu/\r\n\t\tif (charset === 'gb2312' || charset === 'gbk') {\r\n\t\t\tcharset = 'gb18030';\r\n\t\t}\r\n\t}\r\n\r\n\t// turn raw buffers into a single utf-8 buffer\r\n\treturn convert(buffer, 'UTF-8', charset).toString();\r\n}\r\n\r\n/**\r\n * Detect a URLSearchParams object\r\n * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143\r\n *\r\n * @param   Object  obj     Object to detect by type or brand\r\n * @return  String\r\n */\r\nfunction isURLSearchParams(obj) {\r\n\t// Duck-typing as a necessary condition.\r\n\tif (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// Brand-checking and more duck-typing as optional condition.\r\n\treturn obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';\r\n}\r\n\r\n/**\r\n * Check if `obj` is a W3C `Blob` object (which `File` inherits from)\r\n * @param  {*} obj\r\n * @return {boolean}\r\n */\r\nfunction isBlob(obj) {\r\n\treturn typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\r\n}\r\n\r\n/**\r\n * Clone body given Res/Req instance\r\n *\r\n * @param   Mixed  instance  Response or Request instance\r\n * @return  Mixed\r\n */\r\nfunction clone(instance) {\r\n\tlet p1, p2;\r\n\tlet body = instance.body;\r\n\r\n\t// don't allow cloning a used body\r\n\tif (instance.bodyUsed) {\r\n\t\tthrow new Error('cannot clone body after it is used');\r\n\t}\r\n\r\n\t// check that body is a stream and not form-data object\r\n\t// note: we can't clone the form-data object without having it as a dependency\r\n\tif (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__ && typeof body.getBoundary !== 'function') {\r\n\t\t// tee instance body\r\n\t\tp1 = new PassThrough();\r\n\t\tp2 = new PassThrough();\r\n\t\tbody.pipe(p1);\r\n\t\tbody.pipe(p2);\r\n\t\t// set instance body to teed body and return the other teed body\r\n\t\tinstance[INTERNALS].body = p1;\r\n\t\tbody = p2;\r\n\t}\r\n\r\n\treturn body;\r\n}\r\n\r\n/**\r\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\r\n * specified in the specification:\r\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\r\n *\r\n * This function assumes that instance.body is present.\r\n *\r\n * @param   Mixed  instance  Any options.body input\r\n */\r\nfunction extractContentType(body) {\r\n\tif (body === null) {\r\n\t\t// body is null\r\n\t\treturn null;\r\n\t} else if (typeof body === 'string') {\r\n\t\t// body is string\r\n\t\treturn 'text/plain;charset=UTF-8';\r\n\t} else if (isURLSearchParams(body)) {\r\n\t\t// body is a URLSearchParams\r\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\r\n\t} else if (isBlob(body)) {\r\n\t\t// body is blob\r\n\t\treturn body.type || null;\r\n\t} else if (Buffer.isBuffer(body)) {\r\n\t\t// body is buffer\r\n\t\treturn null;\r\n\t} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\r\n\t\t// body is ArrayBuffer\r\n\t\treturn null;\r\n\t} else if (ArrayBuffer.isView(body)) {\r\n\t\t// body is ArrayBufferView\r\n\t\treturn null;\r\n\t} else if (typeof body.getBoundary === 'function') {\r\n\t\t// detect form data input from form-data module\r\n\t\treturn `multipart/form-data;boundary=${body.getBoundary()}`;\r\n\t} else if (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__) {\r\n\t\t// body is stream\r\n\t\t// can't really do much about this\r\n\t\treturn null;\r\n\t} else {\r\n\t\t// Body constructor defaults other things to string\r\n\t\treturn 'text/plain;charset=UTF-8';\r\n\t}\r\n}\r\n\r\n/**\r\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\r\n * For us, we have to explicitly get it with a function.\r\n *\r\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\r\n *\r\n * @param   Body    instance   Instance of Body\r\n * @return  Number?            Number of bytes, or null if not possible\r\n */\r\nfunction getTotalBytes(instance) {\r\n\tconst body = instance.body;\r\n\r\n\r\n\tif (body === null) {\r\n\t\t// body is null\r\n\t\treturn 0;\r\n\t} else if (isBlob(body)) {\r\n\t\treturn body.size;\r\n\t} else if (Buffer.isBuffer(body)) {\r\n\t\t// body is buffer\r\n\t\treturn body.length;\r\n\t} else if (body && typeof body.getLengthSync === 'function') {\r\n\t\t// detect form data input from form-data module\r\n\t\tif (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x\r\n\t\tbody.hasKnownLength && body.hasKnownLength()) {\r\n\t\t\t// 2.x\r\n\t\t\treturn body.getLengthSync();\r\n\t\t}\r\n\t\treturn null;\r\n\t} else {\r\n\t\t// body is stream\r\n\t\treturn null;\r\n\t}\r\n}\r\n\r\n/**\r\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\r\n *\r\n * @param   Body    instance   Instance of Body\r\n * @return  Void\r\n */\r\nfunction writeToStream(dest, instance) {\r\n\tconst body = instance.body;\r\n\r\n\r\n\tif (body === null) {\r\n\t\t// body is null\r\n\t\tdest.end();\r\n\t} else if (isBlob(body)) {\r\n\t\tbody.stream().pipe(dest);\r\n\t} else if (Buffer.isBuffer(body)) {\r\n\t\t// body is buffer\r\n\t\tdest.write(body);\r\n\t\tdest.end();\r\n\t} else {\r\n\t\t// body is stream\r\n\t\tbody.pipe(dest);\r\n\t}\r\n}\r\n\r\n// expose Promise\r\nBody.Promise = global.Promise;\r\n\r\n/**\r\n * headers.js\r\n *\r\n * Headers class offers convenient helpers\r\n */\r\n\r\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\r\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\r\n\r\nfunction validateName(name) {\r\n\tname = `${name}`;\r\n\tif (invalidTokenRegex.test(name) || name === '') {\r\n\t\tthrow new TypeError(`${name} is not a legal HTTP header name`);\r\n\t}\r\n}\r\n\r\nfunction validateValue(value) {\r\n\tvalue = `${value}`;\r\n\tif (invalidHeaderCharRegex.test(value)) {\r\n\t\tthrow new TypeError(`${value} is not a legal HTTP header value`);\r\n\t}\r\n}\r\n\r\n/**\r\n * Find the key in the map object given a header name.\r\n *\r\n * Returns undefined if not found.\r\n *\r\n * @param   String  name  Header name\r\n * @return  String|Undefined\r\n */\r\nfunction find(map, name) {\r\n\tname = name.toLowerCase();\r\n\tfor (const key in map) {\r\n\t\tif (key.toLowerCase() === name) {\r\n\t\t\treturn key;\r\n\t\t}\r\n\t}\r\n\treturn undefined;\r\n}\r\n\r\nconst MAP = Symbol('map');\r\nclass Headers {\r\n\t/**\r\n  * Headers class\r\n  *\r\n  * @param   Object  headers  Response headers\r\n  * @return  Void\r\n  */\r\n\tconstructor() {\r\n\t\tlet init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\r\n\r\n\t\tthis[MAP] = Object.create(null);\r\n\r\n\t\tif (init instanceof Headers) {\r\n\t\t\tconst rawHeaders = init.raw();\r\n\t\t\tconst headerNames = Object.keys(rawHeaders);\r\n\r\n\t\t\tfor (const headerName of headerNames) {\r\n\t\t\t\tfor (const value of rawHeaders[headerName]) {\r\n\t\t\t\t\tthis.append(headerName, value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// We don't worry about converting prop to ByteString here as append()\r\n\t\t// will handle it.\r\n\t\tif (init == null) ; else if (typeof init === 'object') {\r\n\t\t\tconst method = init[Symbol.iterator];\r\n\t\t\tif (method != null) {\r\n\t\t\t\tif (typeof method !== 'function') {\r\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// sequence<sequence<ByteString>>\r\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\r\n\t\t\t\tconst pairs = [];\r\n\t\t\t\tfor (const pair of init) {\r\n\t\t\t\t\tif (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\r\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be iterable');\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpairs.push(Array.from(pair));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (const pair of pairs) {\r\n\t\t\t\t\tif (pair.length !== 2) {\r\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.append(pair[0], pair[1]);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// record<ByteString, ByteString>\r\n\t\t\t\tfor (const key of Object.keys(init)) {\r\n\t\t\t\t\tconst value = init[key];\r\n\t\t\t\t\tthis.append(key, value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthrow new TypeError('Provided initializer must be an object');\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n  * Return combined header value given name\r\n  *\r\n  * @param   String  name  Header name\r\n  * @return  Mixed\r\n  */\r\n\tget(name) {\r\n\t\tname = `${name}`;\r\n\t\tvalidateName(name);\r\n\t\tconst key = find(this[MAP], name);\r\n\t\tif (key === undefined) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn this[MAP][key].join(', ');\r\n\t}\r\n\r\n\t/**\r\n  * Iterate over all headers\r\n  *\r\n  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\r\n  * @param   Boolean   thisArg   `this` context for callback function\r\n  * @return  Void\r\n  */\r\n\tforEach(callback) {\r\n\t\tlet thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\r\n\r\n\t\tlet pairs = getHeaders(this);\r\n\t\tlet i = 0;\r\n\t\twhile (i < pairs.length) {\r\n\t\t\tvar _pairs$i = pairs[i];\r\n\t\t\tconst name = _pairs$i[0],\r\n\t\t\t      value = _pairs$i[1];\r\n\r\n\t\t\tcallback.call(thisArg, value, name, this);\r\n\t\t\tpairs = getHeaders(this);\r\n\t\t\ti++;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n  * Overwrite header values given name\r\n  *\r\n  * @param   String  name   Header name\r\n  * @param   String  value  Header value\r\n  * @return  Void\r\n  */\r\n\tset(name, value) {\r\n\t\tname = `${name}`;\r\n\t\tvalue = `${value}`;\r\n\t\tvalidateName(name);\r\n\t\tvalidateValue(value);\r\n\t\tconst key = find(this[MAP], name);\r\n\t\tthis[MAP][key !== undefined ? key : name] = [value];\r\n\t}\r\n\r\n\t/**\r\n  * Append a value onto existing header\r\n  *\r\n  * @param   String  name   Header name\r\n  * @param   String  value  Header value\r\n  * @return  Void\r\n  */\r\n\tappend(name, value) {\r\n\t\tname = `${name}`;\r\n\t\tvalue = `${value}`;\r\n\t\tvalidateName(name);\r\n\t\tvalidateValue(value);\r\n\t\tconst key = find(this[MAP], name);\r\n\t\tif (key !== undefined) {\r\n\t\t\tthis[MAP][key].push(value);\r\n\t\t} else {\r\n\t\t\tthis[MAP][name] = [value];\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n  * Check for header name existence\r\n  *\r\n  * @param   String   name  Header name\r\n  * @return  Boolean\r\n  */\r\n\thas(name) {\r\n\t\tname = `${name}`;\r\n\t\tvalidateName(name);\r\n\t\treturn find(this[MAP], name) !== undefined;\r\n\t}\r\n\r\n\t/**\r\n  * Delete all header values given name\r\n  *\r\n  * @param   String  name  Header name\r\n  * @return  Void\r\n  */\r\n\tdelete(name) {\r\n\t\tname = `${name}`;\r\n\t\tvalidateName(name);\r\n\t\tconst key = find(this[MAP], name);\r\n\t\tif (key !== undefined) {\r\n\t\t\tdelete this[MAP][key];\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n  * Return raw headers (non-spec api)\r\n  *\r\n  * @return  Object\r\n  */\r\n\traw() {\r\n\t\treturn this[MAP];\r\n\t}\r\n\r\n\t/**\r\n  * Get an iterator on keys.\r\n  *\r\n  * @return  Iterator\r\n  */\r\n\tkeys() {\r\n\t\treturn createHeadersIterator(this, 'key');\r\n\t}\r\n\r\n\t/**\r\n  * Get an iterator on values.\r\n  *\r\n  * @return  Iterator\r\n  */\r\n\tvalues() {\r\n\t\treturn createHeadersIterator(this, 'value');\r\n\t}\r\n\r\n\t/**\r\n  * Get an iterator on entries.\r\n  *\r\n  * This is the default iterator of the Headers object.\r\n  *\r\n  * @return  Iterator\r\n  */\r\n\t[Symbol.iterator]() {\r\n\t\treturn createHeadersIterator(this, 'key+value');\r\n\t}\r\n}\r\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\r\n\r\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\r\n\tvalue: 'Headers',\r\n\twritable: false,\r\n\tenumerable: false,\r\n\tconfigurable: true\r\n});\r\n\r\nObject.defineProperties(Headers.prototype, {\r\n\tget: { enumerable: true },\r\n\tforEach: { enumerable: true },\r\n\tset: { enumerable: true },\r\n\tappend: { enumerable: true },\r\n\thas: { enumerable: true },\r\n\tdelete: { enumerable: true },\r\n\tkeys: { enumerable: true },\r\n\tvalues: { enumerable: true },\r\n\tentries: { enumerable: true }\r\n});\r\n\r\nfunction getHeaders(headers) {\r\n\tlet kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';\r\n\r\n\tconst keys = Object.keys(headers[MAP]).sort();\r\n\treturn keys.map(kind === 'key' ? function (k) {\r\n\t\treturn k.toLowerCase();\r\n\t} : kind === 'value' ? function (k) {\r\n\t\treturn headers[MAP][k].join(', ');\r\n\t} : function (k) {\r\n\t\treturn [k.toLowerCase(), headers[MAP][k].join(', ')];\r\n\t});\r\n}\r\n\r\nconst INTERNAL = Symbol('internal');\r\n\r\nfunction createHeadersIterator(target, kind) {\r\n\tconst iterator = Object.create(HeadersIteratorPrototype);\r\n\titerator[INTERNAL] = {\r\n\t\ttarget,\r\n\t\tkind,\r\n\t\tindex: 0\r\n\t};\r\n\treturn iterator;\r\n}\r\n\r\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\r\n\tnext() {\r\n\t\t// istanbul ignore if\r\n\t\tif (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\r\n\t\t\tthrow new TypeError('Value of `this` is not a HeadersIterator');\r\n\t\t}\r\n\r\n\t\tvar _INTERNAL = this[INTERNAL];\r\n\t\tconst target = _INTERNAL.target,\r\n\t\t      kind = _INTERNAL.kind,\r\n\t\t      index = _INTERNAL.index;\r\n\r\n\t\tconst values = getHeaders(target, kind);\r\n\t\tconst len = values.length;\r\n\t\tif (index >= len) {\r\n\t\t\treturn {\r\n\t\t\t\tvalue: undefined,\r\n\t\t\t\tdone: true\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tthis[INTERNAL].index = index + 1;\r\n\r\n\t\treturn {\r\n\t\t\tvalue: values[index],\r\n\t\t\tdone: false\r\n\t\t};\r\n\t}\r\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\r\n\r\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\r\n\tvalue: 'HeadersIterator',\r\n\twritable: false,\r\n\tenumerable: false,\r\n\tconfigurable: true\r\n});\r\n\r\n/**\r\n * Export the Headers object in a form that Node.js can consume.\r\n *\r\n * @param   Headers  headers\r\n * @return  Object\r\n */\r\nfunction exportNodeCompatibleHeaders(headers) {\r\n\tconst obj = Object.assign({ __proto__: null }, headers[MAP]);\r\n\r\n\t// http.request() only supports string as Host header. This hack makes\r\n\t// specifying custom Host header possible.\r\n\tconst hostHeaderKey = find(headers[MAP], 'Host');\r\n\tif (hostHeaderKey !== undefined) {\r\n\t\tobj[hostHeaderKey] = obj[hostHeaderKey][0];\r\n\t}\r\n\r\n\treturn obj;\r\n}\r\n\r\n/**\r\n * Create a Headers object from an object of headers, ignoring those that do\r\n * not conform to HTTP grammar productions.\r\n *\r\n * @param   Object  obj  Object of headers\r\n * @return  Headers\r\n */\r\nfunction createHeadersLenient(obj) {\r\n\tconst headers = new Headers();\r\n\tfor (const name of Object.keys(obj)) {\r\n\t\tif (invalidTokenRegex.test(name)) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (Array.isArray(obj[name])) {\r\n\t\t\tfor (const val of obj[name]) {\r\n\t\t\t\tif (invalidHeaderCharRegex.test(val)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (headers[MAP][name] === undefined) {\r\n\t\t\t\t\theaders[MAP][name] = [val];\r\n\t\t\t\t} else {\r\n\t\t\t\t\theaders[MAP][name].push(val);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (!invalidHeaderCharRegex.test(obj[name])) {\r\n\t\t\theaders[MAP][name] = [obj[name]];\r\n\t\t}\r\n\t}\r\n\treturn headers;\r\n}\r\n\r\nconst INTERNALS$1 = Symbol('Response internals');\r\n\r\n// fix an issue where \"STATUS_CODES\" aren't a named export for node <10\r\nconst STATUS_CODES = http__WEBPACK_IMPORTED_MODULE_1__.STATUS_CODES;\r\n\r\n/**\r\n * Response class\r\n *\r\n * @param   Stream  body  Readable stream\r\n * @param   Object  opts  Response options\r\n * @return  Void\r\n */\r\nclass Response {\r\n\tconstructor() {\r\n\t\tlet body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\r\n\t\tlet opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n\r\n\t\tBody.call(this, body, opts);\r\n\r\n\t\tconst status = opts.status || 200;\r\n\t\tconst headers = new Headers(opts.headers);\r\n\r\n\t\tif (body != null && !headers.has('Content-Type')) {\r\n\t\t\tconst contentType = extractContentType(body);\r\n\t\t\tif (contentType) {\r\n\t\t\t\theaders.append('Content-Type', contentType);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis[INTERNALS$1] = {\r\n\t\t\turl: opts.url,\r\n\t\t\tstatus,\r\n\t\t\tstatusText: opts.statusText || STATUS_CODES[status],\r\n\t\t\theaders,\r\n\t\t\tcounter: opts.counter\r\n\t\t};\r\n\t}\r\n\r\n\tget url() {\r\n\t\treturn this[INTERNALS$1].url || '';\r\n\t}\r\n\r\n\tget status() {\r\n\t\treturn this[INTERNALS$1].status;\r\n\t}\r\n\r\n\t/**\r\n  * Convenience property representing if the request ended normally\r\n  */\r\n\tget ok() {\r\n\t\treturn this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\r\n\t}\r\n\r\n\tget redirected() {\r\n\t\treturn this[INTERNALS$1].counter > 0;\r\n\t}\r\n\r\n\tget statusText() {\r\n\t\treturn this[INTERNALS$1].statusText;\r\n\t}\r\n\r\n\tget headers() {\r\n\t\treturn this[INTERNALS$1].headers;\r\n\t}\r\n\r\n\t/**\r\n  * Clone this response\r\n  *\r\n  * @return  Response\r\n  */\r\n\tclone() {\r\n\t\treturn new Response(clone(this), {\r\n\t\t\turl: this.url,\r\n\t\t\tstatus: this.status,\r\n\t\t\tstatusText: this.statusText,\r\n\t\t\theaders: this.headers,\r\n\t\t\tok: this.ok,\r\n\t\t\tredirected: this.redirected\r\n\t\t});\r\n\t}\r\n}\r\n\r\nBody.mixIn(Response.prototype);\r\n\r\nObject.defineProperties(Response.prototype, {\r\n\turl: { enumerable: true },\r\n\tstatus: { enumerable: true },\r\n\tok: { enumerable: true },\r\n\tredirected: { enumerable: true },\r\n\tstatusText: { enumerable: true },\r\n\theaders: { enumerable: true },\r\n\tclone: { enumerable: true }\r\n});\r\n\r\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\r\n\tvalue: 'Response',\r\n\twritable: false,\r\n\tenumerable: false,\r\n\tconfigurable: true\r\n});\r\n\r\nconst INTERNALS$2 = Symbol('Request internals');\r\n\r\n// fix an issue where \"format\", \"parse\" aren't a named export for node <10\r\nconst parse_url = url__WEBPACK_IMPORTED_MODULE_2__.parse;\r\nconst format_url = url__WEBPACK_IMPORTED_MODULE_2__.format;\r\n\r\nconst streamDestructionSupported = 'destroy' in stream__WEBPACK_IMPORTED_MODULE_0__.Readable.prototype;\r\n\r\n/**\r\n * Check if a value is an instance of Request.\r\n *\r\n * @param   Mixed   input\r\n * @return  Boolean\r\n */\r\nfunction isRequest(input) {\r\n\treturn typeof input === 'object' && typeof input[INTERNALS$2] === 'object';\r\n}\r\n\r\nfunction isAbortSignal(signal) {\r\n\tconst proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);\r\n\treturn !!(proto && proto.constructor.name === 'AbortSignal');\r\n}\r\n\r\n/**\r\n * Request class\r\n *\r\n * @param   Mixed   input  Url or Request instance\r\n * @param   Object  init   Custom options\r\n * @return  Void\r\n */\r\nclass Request {\r\n\tconstructor(input) {\r\n\t\tlet init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n\r\n\t\tlet parsedURL;\r\n\r\n\t\t// normalize input\r\n\t\tif (!isRequest(input)) {\r\n\t\t\tif (input && input.href) {\r\n\t\t\t\t// in order to support Node.js' Url objects; though WHATWG's URL objects\r\n\t\t\t\t// will fall into this branch also (since their `toString()` will return\r\n\t\t\t\t// `href` property anyway)\r\n\t\t\t\tparsedURL = parse_url(input.href);\r\n\t\t\t} else {\r\n\t\t\t\t// coerce input to a string before attempting to parse\r\n\t\t\t\tparsedURL = parse_url(`${input}`);\r\n\t\t\t}\r\n\t\t\tinput = {};\r\n\t\t} else {\r\n\t\t\tparsedURL = parse_url(input.url);\r\n\t\t}\r\n\r\n\t\tlet method = init.method || input.method || 'GET';\r\n\t\tmethod = method.toUpperCase();\r\n\r\n\t\tif ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {\r\n\t\t\tthrow new TypeError('Request with GET/HEAD method cannot have body');\r\n\t\t}\r\n\r\n\t\tlet inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\r\n\r\n\t\tBody.call(this, inputBody, {\r\n\t\t\ttimeout: init.timeout || input.timeout || 0,\r\n\t\t\tsize: init.size || input.size || 0\r\n\t\t});\r\n\r\n\t\tconst headers = new Headers(init.headers || input.headers || {});\r\n\r\n\t\tif (inputBody != null && !headers.has('Content-Type')) {\r\n\t\t\tconst contentType = extractContentType(inputBody);\r\n\t\t\tif (contentType) {\r\n\t\t\t\theaders.append('Content-Type', contentType);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet signal = isRequest(input) ? input.signal : null;\r\n\t\tif ('signal' in init) signal = init.signal;\r\n\r\n\t\tif (signal != null && !isAbortSignal(signal)) {\r\n\t\t\tthrow new TypeError('Expected signal to be an instanceof AbortSignal');\r\n\t\t}\r\n\r\n\t\tthis[INTERNALS$2] = {\r\n\t\t\tmethod,\r\n\t\t\tredirect: init.redirect || input.redirect || 'follow',\r\n\t\t\theaders,\r\n\t\t\tparsedURL,\r\n\t\t\tsignal\r\n\t\t};\r\n\r\n\t\t// node-fetch-only options\r\n\t\tthis.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\r\n\t\tthis.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\r\n\t\tthis.counter = init.counter || input.counter || 0;\r\n\t\tthis.agent = init.agent || input.agent;\r\n\t}\r\n\r\n\tget method() {\r\n\t\treturn this[INTERNALS$2].method;\r\n\t}\r\n\r\n\tget url() {\r\n\t\treturn format_url(this[INTERNALS$2].parsedURL);\r\n\t}\r\n\r\n\tget headers() {\r\n\t\treturn this[INTERNALS$2].headers;\r\n\t}\r\n\r\n\tget redirect() {\r\n\t\treturn this[INTERNALS$2].redirect;\r\n\t}\r\n\r\n\tget signal() {\r\n\t\treturn this[INTERNALS$2].signal;\r\n\t}\r\n\r\n\t/**\r\n  * Clone this request\r\n  *\r\n  * @return  Request\r\n  */\r\n\tclone() {\r\n\t\treturn new Request(this);\r\n\t}\r\n}\r\n\r\nBody.mixIn(Request.prototype);\r\n\r\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\r\n\tvalue: 'Request',\r\n\twritable: false,\r\n\tenumerable: false,\r\n\tconfigurable: true\r\n});\r\n\r\nObject.defineProperties(Request.prototype, {\r\n\tmethod: { enumerable: true },\r\n\turl: { enumerable: true },\r\n\theaders: { enumerable: true },\r\n\tredirect: { enumerable: true },\r\n\tclone: { enumerable: true },\r\n\tsignal: { enumerable: true }\r\n});\r\n\r\n/**\r\n * Convert a Request to Node.js http request options.\r\n *\r\n * @param   Request  A Request instance\r\n * @return  Object   The options object to be passed to http.request\r\n */\r\nfunction getNodeRequestOptions(request) {\r\n\tconst parsedURL = request[INTERNALS$2].parsedURL;\r\n\tconst headers = new Headers(request[INTERNALS$2].headers);\r\n\r\n\t// fetch step 1.3\r\n\tif (!headers.has('Accept')) {\r\n\t\theaders.set('Accept', '*/*');\r\n\t}\r\n\r\n\t// Basic fetch\r\n\tif (!parsedURL.protocol || !parsedURL.hostname) {\r\n\t\tthrow new TypeError('Only absolute URLs are supported');\r\n\t}\r\n\r\n\tif (!/^https?:$/.test(parsedURL.protocol)) {\r\n\t\tthrow new TypeError('Only HTTP(S) protocols are supported');\r\n\t}\r\n\r\n\tif (request.signal && request.body instanceof stream__WEBPACK_IMPORTED_MODULE_0__.Readable && !streamDestructionSupported) {\r\n\t\tthrow new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');\r\n\t}\r\n\r\n\t// HTTP-network-or-cache fetch steps 2.4-2.7\r\n\tlet contentLengthValue = null;\r\n\tif (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\r\n\t\tcontentLengthValue = '0';\r\n\t}\r\n\tif (request.body != null) {\r\n\t\tconst totalBytes = getTotalBytes(request);\r\n\t\tif (typeof totalBytes === 'number') {\r\n\t\t\tcontentLengthValue = String(totalBytes);\r\n\t\t}\r\n\t}\r\n\tif (contentLengthValue) {\r\n\t\theaders.set('Content-Length', contentLengthValue);\r\n\t}\r\n\r\n\t// HTTP-network-or-cache fetch step 2.11\r\n\tif (!headers.has('User-Agent')) {\r\n\t\theaders.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');\r\n\t}\r\n\r\n\t// HTTP-network-or-cache fetch step 2.15\r\n\tif (request.compress && !headers.has('Accept-Encoding')) {\r\n\t\theaders.set('Accept-Encoding', 'gzip,deflate');\r\n\t}\r\n\r\n\tlet agent = request.agent;\r\n\tif (typeof agent === 'function') {\r\n\t\tagent = agent(parsedURL);\r\n\t}\r\n\r\n\tif (!headers.has('Connection') && !agent) {\r\n\t\theaders.set('Connection', 'close');\r\n\t}\r\n\r\n\t// HTTP-network fetch step 4.2\r\n\t// chunked encoding is handled by Node.js\r\n\r\n\treturn Object.assign({}, parsedURL, {\r\n\t\tmethod: request.method,\r\n\t\theaders: exportNodeCompatibleHeaders(headers),\r\n\t\tagent\r\n\t});\r\n}\r\n\r\n/**\r\n * abort-error.js\r\n *\r\n * AbortError interface for cancelled requests\r\n */\r\n\r\n/**\r\n * Create AbortError instance\r\n *\r\n * @param   String      message      Error message for human\r\n * @return  AbortError\r\n */\r\nfunction AbortError(message) {\r\n  Error.call(this, message);\r\n\r\n  this.type = 'aborted';\r\n  this.message = message;\r\n\r\n  // hide custom error implementation details from end-users\r\n  Error.captureStackTrace(this, this.constructor);\r\n}\r\n\r\nAbortError.prototype = Object.create(Error.prototype);\r\nAbortError.prototype.constructor = AbortError;\r\nAbortError.prototype.name = 'AbortError';\r\n\r\n// fix an issue where \"PassThrough\", \"resolve\" aren't a named export for node <10\r\nconst PassThrough$1 = stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough;\r\nconst resolve_url = url__WEBPACK_IMPORTED_MODULE_2__.resolve;\r\n\r\n/**\r\n * Fetch function\r\n *\r\n * @param   Mixed    url   Absolute url or Request instance\r\n * @param   Object   opts  Fetch options\r\n * @return  Promise\r\n */\r\nfunction fetch(url, opts) {\r\n\r\n\t// allow custom promise\r\n\tif (!fetch.Promise) {\r\n\t\tthrow new Error('native promise missing, set fetch.Promise to your favorite alternative');\r\n\t}\r\n\r\n\tBody.Promise = fetch.Promise;\r\n\r\n\t// wrap http.request into fetch\r\n\treturn new fetch.Promise(function (resolve, reject) {\r\n\t\t// build request object\r\n\t\tconst request = new Request(url, opts);\r\n\t\tconst options = getNodeRequestOptions(request);\r\n\r\n\t\tconst send = (options.protocol === 'https:' ? https__WEBPACK_IMPORTED_MODULE_3__ : http__WEBPACK_IMPORTED_MODULE_1__).request;\r\n\t\tconst signal = request.signal;\r\n\r\n\t\tlet response = null;\r\n\r\n\t\tconst abort = function abort() {\r\n\t\t\tlet error = new AbortError('The user aborted a request.');\r\n\t\t\treject(error);\r\n\t\t\tif (request.body && request.body instanceof stream__WEBPACK_IMPORTED_MODULE_0__.Readable) {\r\n\t\t\t\trequest.body.destroy(error);\r\n\t\t\t}\r\n\t\t\tif (!response || !response.body) return;\r\n\t\t\tresponse.body.emit('error', error);\r\n\t\t};\r\n\r\n\t\tif (signal && signal.aborted) {\r\n\t\t\tabort();\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst abortAndFinalize = function abortAndFinalize() {\r\n\t\t\tabort();\r\n\t\t\tfinalize();\r\n\t\t};\r\n\r\n\t\t// send request\r\n\t\tconst req = send(options);\r\n\t\tlet reqTimeout;\r\n\r\n\t\tif (signal) {\r\n\t\t\tsignal.addEventListener('abort', abortAndFinalize);\r\n\t\t}\r\n\r\n\t\tfunction finalize() {\r\n\t\t\treq.abort();\r\n\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\r\n\t\t\tclearTimeout(reqTimeout);\r\n\t\t}\r\n\r\n\t\tif (request.timeout) {\r\n\t\t\treq.once('socket', function (socket) {\r\n\t\t\t\treqTimeout = setTimeout(function () {\r\n\t\t\t\t\treject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\r\n\t\t\t\t\tfinalize();\r\n\t\t\t\t}, request.timeout);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treq.on('error', function (err) {\r\n\t\t\treject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));\r\n\t\t\tfinalize();\r\n\t\t});\r\n\r\n\t\treq.on('response', function (res) {\r\n\t\t\tclearTimeout(reqTimeout);\r\n\r\n\t\t\tconst headers = createHeadersLenient(res.headers);\r\n\r\n\t\t\t// HTTP fetch step 5\r\n\t\t\tif (fetch.isRedirect(res.statusCode)) {\r\n\t\t\t\t// HTTP fetch step 5.2\r\n\t\t\t\tconst location = headers.get('Location');\r\n\r\n\t\t\t\t// HTTP fetch step 5.3\r\n\t\t\t\tconst locationURL = location === null ? null : resolve_url(request.url, location);\r\n\r\n\t\t\t\t// HTTP fetch step 5.5\r\n\t\t\t\tswitch (request.redirect) {\r\n\t\t\t\t\tcase 'error':\r\n\t\t\t\t\t\treject(new FetchError(`redirect mode is set to error: ${request.url}`, 'no-redirect'));\r\n\t\t\t\t\t\tfinalize();\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase 'manual':\r\n\t\t\t\t\t\t// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.\r\n\t\t\t\t\t\tif (locationURL !== null) {\r\n\t\t\t\t\t\t\t// handle corrupted header\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\theaders.set('Location', locationURL);\r\n\t\t\t\t\t\t\t} catch (err) {\r\n\t\t\t\t\t\t\t\t// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request\r\n\t\t\t\t\t\t\t\treject(err);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'follow':\r\n\t\t\t\t\t\t// HTTP-redirect fetch step 2\r\n\t\t\t\t\t\tif (locationURL === null) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// HTTP-redirect fetch step 5\r\n\t\t\t\t\t\tif (request.counter >= request.follow) {\r\n\t\t\t\t\t\t\treject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\r\n\t\t\t\t\t\t\tfinalize();\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// HTTP-redirect fetch step 6 (counter increment)\r\n\t\t\t\t\t\t// Create a new Request object.\r\n\t\t\t\t\t\tconst requestOpts = {\r\n\t\t\t\t\t\t\theaders: new Headers(request.headers),\r\n\t\t\t\t\t\t\tfollow: request.follow,\r\n\t\t\t\t\t\t\tcounter: request.counter + 1,\r\n\t\t\t\t\t\t\tagent: request.agent,\r\n\t\t\t\t\t\t\tcompress: request.compress,\r\n\t\t\t\t\t\t\tmethod: request.method,\r\n\t\t\t\t\t\t\tbody: request.body,\r\n\t\t\t\t\t\t\tsignal: request.signal,\r\n\t\t\t\t\t\t\ttimeout: request.timeout\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t// HTTP-redirect fetch step 9\r\n\t\t\t\t\t\tif (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\r\n\t\t\t\t\t\t\treject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\r\n\t\t\t\t\t\t\tfinalize();\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// HTTP-redirect fetch step 11\r\n\t\t\t\t\t\tif (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\r\n\t\t\t\t\t\t\trequestOpts.method = 'GET';\r\n\t\t\t\t\t\t\trequestOpts.body = undefined;\r\n\t\t\t\t\t\t\trequestOpts.headers.delete('content-length');\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// HTTP-redirect fetch step 15\r\n\t\t\t\t\t\tresolve(fetch(new Request(locationURL, requestOpts)));\r\n\t\t\t\t\t\tfinalize();\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// prepare response\r\n\t\t\tres.once('end', function () {\r\n\t\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\r\n\t\t\t});\r\n\t\t\tlet body = res.pipe(new PassThrough$1());\r\n\r\n\t\t\tconst response_options = {\r\n\t\t\t\turl: request.url,\r\n\t\t\t\tstatus: res.statusCode,\r\n\t\t\t\tstatusText: res.statusMessage,\r\n\t\t\t\theaders: headers,\r\n\t\t\t\tsize: request.size,\r\n\t\t\t\ttimeout: request.timeout,\r\n\t\t\t\tcounter: request.counter\r\n\t\t\t};\r\n\r\n\t\t\t// HTTP-network fetch step 12.1.1.3\r\n\t\t\tconst codings = headers.get('Content-Encoding');\r\n\r\n\t\t\t// HTTP-network fetch step 12.1.1.4: handle content codings\r\n\r\n\t\t\t// in following scenarios we ignore compression support\r\n\t\t\t// 1. compression support is disabled\r\n\t\t\t// 2. HEAD request\r\n\t\t\t// 3. no Content-Encoding header\r\n\t\t\t// 4. no content response (204)\r\n\t\t\t// 5. content not modified response (304)\r\n\t\t\tif (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\r\n\t\t\t\tresponse = new Response(body, response_options);\r\n\t\t\t\tresolve(response);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// For Node v6+\r\n\t\t\t// Be less strict when decoding compressed responses, since sometimes\r\n\t\t\t// servers send slightly invalid responses that are still accepted\r\n\t\t\t// by common browsers.\r\n\t\t\t// Always using Z_SYNC_FLUSH is what cURL does.\r\n\t\t\tconst zlibOptions = {\r\n\t\t\t\tflush: zlib__WEBPACK_IMPORTED_MODULE_4__.Z_SYNC_FLUSH,\r\n\t\t\t\tfinishFlush: zlib__WEBPACK_IMPORTED_MODULE_4__.Z_SYNC_FLUSH\r\n\t\t\t};\r\n\r\n\t\t\t// for gzip\r\n\t\t\tif (codings == 'gzip' || codings == 'x-gzip') {\r\n\t\t\t\tbody = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_4__.createGunzip(zlibOptions));\r\n\t\t\t\tresponse = new Response(body, response_options);\r\n\t\t\t\tresolve(response);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// for deflate\r\n\t\t\tif (codings == 'deflate' || codings == 'x-deflate') {\r\n\t\t\t\t// handle the infamous raw deflate response from old servers\r\n\t\t\t\t// a hack for old IIS and Apache servers\r\n\t\t\t\tconst raw = res.pipe(new PassThrough$1());\r\n\t\t\t\traw.once('data', function (chunk) {\r\n\t\t\t\t\t// see http://stackoverflow.com/questions/37519828\r\n\t\t\t\t\tif ((chunk[0] & 0x0F) === 0x08) {\r\n\t\t\t\t\t\tbody = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_4__.createInflate());\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tbody = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_4__.createInflateRaw());\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresponse = new Response(body, response_options);\r\n\t\t\t\t\tresolve(response);\r\n\t\t\t\t});\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// for br\r\n\t\t\tif (codings == 'br' && typeof zlib__WEBPACK_IMPORTED_MODULE_4__.createBrotliDecompress === 'function') {\r\n\t\t\t\tbody = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_4__.createBrotliDecompress());\r\n\t\t\t\tresponse = new Response(body, response_options);\r\n\t\t\t\tresolve(response);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// otherwise, use response as-is\r\n\t\t\tresponse = new Response(body, response_options);\r\n\t\t\tresolve(response);\r\n\t\t});\r\n\r\n\t\twriteToStream(req, request);\r\n\t});\r\n}\r\n/**\r\n * Redirect code matching\r\n *\r\n * @param   Number   code  Status code\r\n * @return  Boolean\r\n */\r\nfetch.isRedirect = function (code) {\r\n\treturn code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\r\n};\r\n\r\n// expose Promise\r\nfetch.Promise = global.Promise;\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (fetch);\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9saWIvaW5kZXgubWpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gvbGliL2luZGV4Lm1qcz85YjQzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTdHJlYW0gZnJvbSAnc3RyZWFtJztcclxuaW1wb3J0IGh0dHAgZnJvbSAnaHR0cCc7XHJcbmltcG9ydCBVcmwgZnJvbSAndXJsJztcclxuaW1wb3J0IGh0dHBzIGZyb20gJ2h0dHBzJztcclxuaW1wb3J0IHpsaWIgZnJvbSAnemxpYic7XHJcblxyXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vdG1wdmFyL2pzZG9tL2Jsb2IvYWE4NWIyYWJmMDc3NjZmZjdiZjVjMWY2ZGFhZmIzNzI2ZjJmMmRiNS9saWIvanNkb20vbGl2aW5nL2Jsb2IuanNcclxuXHJcbi8vIGZpeCBmb3IgXCJSZWFkYWJsZVwiIGlzbid0IGEgbmFtZWQgZXhwb3J0IGlzc3VlXHJcbmNvbnN0IFJlYWRhYmxlID0gU3RyZWFtLlJlYWRhYmxlO1xyXG5cclxuY29uc3QgQlVGRkVSID0gU3ltYm9sKCdidWZmZXInKTtcclxuY29uc3QgVFlQRSA9IFN5bWJvbCgndHlwZScpO1xyXG5cclxuY2xhc3MgQmxvYiB7XHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHR0aGlzW1RZUEVdID0gJyc7XHJcblxyXG5cdFx0Y29uc3QgYmxvYlBhcnRzID0gYXJndW1lbnRzWzBdO1xyXG5cdFx0Y29uc3Qgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXTtcclxuXHJcblx0XHRjb25zdCBidWZmZXJzID0gW107XHJcblx0XHRsZXQgc2l6ZSA9IDA7XHJcblxyXG5cdFx0aWYgKGJsb2JQYXJ0cykge1xyXG5cdFx0XHRjb25zdCBhID0gYmxvYlBhcnRzO1xyXG5cdFx0XHRjb25zdCBsZW5ndGggPSBOdW1iZXIoYS5sZW5ndGgpO1xyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0Y29uc3QgZWxlbWVudCA9IGFbaV07XHJcblx0XHRcdFx0bGV0IGJ1ZmZlcjtcclxuXHRcdFx0XHRpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEJ1ZmZlcikge1xyXG5cdFx0XHRcdFx0YnVmZmVyID0gZWxlbWVudDtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhlbGVtZW50KSkge1xyXG5cdFx0XHRcdFx0YnVmZmVyID0gQnVmZmVyLmZyb20oZWxlbWVudC5idWZmZXIsIGVsZW1lbnQuYnl0ZU9mZnNldCwgZWxlbWVudC5ieXRlTGVuZ3RoKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xyXG5cdFx0XHRcdFx0YnVmZmVyID0gQnVmZmVyLmZyb20oZWxlbWVudCk7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChlbGVtZW50IGluc3RhbmNlb2YgQmxvYikge1xyXG5cdFx0XHRcdFx0YnVmZmVyID0gZWxlbWVudFtCVUZGRVJdO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRidWZmZXIgPSBCdWZmZXIuZnJvbSh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgPyBlbGVtZW50IDogU3RyaW5nKGVsZW1lbnQpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0c2l6ZSArPSBidWZmZXIubGVuZ3RoO1xyXG5cdFx0XHRcdGJ1ZmZlcnMucHVzaChidWZmZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpc1tCVUZGRVJdID0gQnVmZmVyLmNvbmNhdChidWZmZXJzKTtcclxuXHJcblx0XHRsZXQgdHlwZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlICE9PSB1bmRlZmluZWQgJiYgU3RyaW5nKG9wdGlvbnMudHlwZSkudG9Mb3dlckNhc2UoKTtcclxuXHRcdGlmICh0eXBlICYmICEvW15cXHUwMDIwLVxcdTAwN0VdLy50ZXN0KHR5cGUpKSB7XHJcblx0XHRcdHRoaXNbVFlQRV0gPSB0eXBlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRnZXQgc2l6ZSgpIHtcclxuXHRcdHJldHVybiB0aGlzW0JVRkZFUl0ubGVuZ3RoO1xyXG5cdH1cclxuXHRnZXQgdHlwZSgpIHtcclxuXHRcdHJldHVybiB0aGlzW1RZUEVdO1xyXG5cdH1cclxuXHR0ZXh0KCkge1xyXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzW0JVRkZFUl0udG9TdHJpbmcoKSk7XHJcblx0fVxyXG5cdGFycmF5QnVmZmVyKCkge1xyXG5cdFx0Y29uc3QgYnVmID0gdGhpc1tCVUZGRVJdO1xyXG5cdFx0Y29uc3QgYWIgPSBidWYuYnVmZmVyLnNsaWNlKGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZU9mZnNldCArIGJ1Zi5ieXRlTGVuZ3RoKTtcclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoYWIpO1xyXG5cdH1cclxuXHRzdHJlYW0oKSB7XHJcblx0XHRjb25zdCByZWFkYWJsZSA9IG5ldyBSZWFkYWJsZSgpO1xyXG5cdFx0cmVhZGFibGUuX3JlYWQgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHRcdHJlYWRhYmxlLnB1c2godGhpc1tCVUZGRVJdKTtcclxuXHRcdHJlYWRhYmxlLnB1c2gobnVsbCk7XHJcblx0XHRyZXR1cm4gcmVhZGFibGU7XHJcblx0fVxyXG5cdHRvU3RyaW5nKCkge1xyXG5cdFx0cmV0dXJuICdbb2JqZWN0IEJsb2JdJztcclxuXHR9XHJcblx0c2xpY2UoKSB7XHJcblx0XHRjb25zdCBzaXplID0gdGhpcy5zaXplO1xyXG5cclxuXHRcdGNvbnN0IHN0YXJ0ID0gYXJndW1lbnRzWzBdO1xyXG5cdFx0Y29uc3QgZW5kID0gYXJndW1lbnRzWzFdO1xyXG5cdFx0bGV0IHJlbGF0aXZlU3RhcnQsIHJlbGF0aXZlRW5kO1xyXG5cdFx0aWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0cmVsYXRpdmVTdGFydCA9IDA7XHJcblx0XHR9IGVsc2UgaWYgKHN0YXJ0IDwgMCkge1xyXG5cdFx0XHRyZWxhdGl2ZVN0YXJ0ID0gTWF0aC5tYXgoc2l6ZSArIHN0YXJ0LCAwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlbGF0aXZlU3RhcnQgPSBNYXRoLm1pbihzdGFydCwgc2l6ZSk7XHJcblx0XHR9XHJcblx0XHRpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0cmVsYXRpdmVFbmQgPSBzaXplO1xyXG5cdFx0fSBlbHNlIGlmIChlbmQgPCAwKSB7XHJcblx0XHRcdHJlbGF0aXZlRW5kID0gTWF0aC5tYXgoc2l6ZSArIGVuZCwgMCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZWxhdGl2ZUVuZCA9IE1hdGgubWluKGVuZCwgc2l6ZSk7XHJcblx0XHR9XHJcblx0XHRjb25zdCBzcGFuID0gTWF0aC5tYXgocmVsYXRpdmVFbmQgLSByZWxhdGl2ZVN0YXJ0LCAwKTtcclxuXHJcblx0XHRjb25zdCBidWZmZXIgPSB0aGlzW0JVRkZFUl07XHJcblx0XHRjb25zdCBzbGljZWRCdWZmZXIgPSBidWZmZXIuc2xpY2UocmVsYXRpdmVTdGFydCwgcmVsYXRpdmVTdGFydCArIHNwYW4pO1xyXG5cdFx0Y29uc3QgYmxvYiA9IG5ldyBCbG9iKFtdLCB7IHR5cGU6IGFyZ3VtZW50c1syXSB9KTtcclxuXHRcdGJsb2JbQlVGRkVSXSA9IHNsaWNlZEJ1ZmZlcjtcclxuXHRcdHJldHVybiBibG9iO1xyXG5cdH1cclxufVxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQmxvYi5wcm90b3R5cGUsIHtcclxuXHRzaXplOiB7IGVudW1lcmFibGU6IHRydWUgfSxcclxuXHR0eXBlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcclxuXHRzbGljZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cclxufSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmxvYi5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xyXG5cdHZhbHVlOiAnQmxvYicsXHJcblx0d3JpdGFibGU6IGZhbHNlLFxyXG5cdGVudW1lcmFibGU6IGZhbHNlLFxyXG5cdGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBmZXRjaC1lcnJvci5qc1xyXG4gKlxyXG4gKiBGZXRjaEVycm9yIGludGVyZmFjZSBmb3Igb3BlcmF0aW9uYWwgZXJyb3JzXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBGZXRjaEVycm9yIGluc3RhbmNlXHJcbiAqXHJcbiAqIEBwYXJhbSAgIFN0cmluZyAgICAgIG1lc3NhZ2UgICAgICBFcnJvciBtZXNzYWdlIGZvciBodW1hblxyXG4gKiBAcGFyYW0gICBTdHJpbmcgICAgICB0eXBlICAgICAgICAgRXJyb3IgdHlwZSBmb3IgbWFjaGluZVxyXG4gKiBAcGFyYW0gICBTdHJpbmcgICAgICBzeXN0ZW1FcnJvciAgRm9yIE5vZGUuanMgc3lzdGVtIGVycm9yXHJcbiAqIEByZXR1cm4gIEZldGNoRXJyb3JcclxuICovXHJcbmZ1bmN0aW9uIEZldGNoRXJyb3IobWVzc2FnZSwgdHlwZSwgc3lzdGVtRXJyb3IpIHtcclxuICBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xyXG5cclxuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gIHRoaXMudHlwZSA9IHR5cGU7XHJcblxyXG4gIC8vIHdoZW4gZXJyLnR5cGUgaXMgYHN5c3RlbWAsIGVyci5jb2RlIGNvbnRhaW5zIHN5c3RlbSBlcnJvciBjb2RlXHJcbiAgaWYgKHN5c3RlbUVycm9yKSB7XHJcbiAgICB0aGlzLmNvZGUgPSB0aGlzLmVycm5vID0gc3lzdGVtRXJyb3IuY29kZTtcclxuICB9XHJcblxyXG4gIC8vIGhpZGUgY3VzdG9tIGVycm9yIGltcGxlbWVudGF0aW9uIGRldGFpbHMgZnJvbSBlbmQtdXNlcnNcclxuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcclxufVxyXG5cclxuRmV0Y2hFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XHJcbkZldGNoRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmV0Y2hFcnJvcjtcclxuRmV0Y2hFcnJvci5wcm90b3R5cGUubmFtZSA9ICdGZXRjaEVycm9yJztcclxuXHJcbmxldCBjb252ZXJ0O1xyXG50cnkge1xyXG5cdGNvbnZlcnQgPSByZXF1aXJlKCdlbmNvZGluZycpLmNvbnZlcnQ7XHJcbn0gY2F0Y2ggKGUpIHt9XHJcblxyXG5jb25zdCBJTlRFUk5BTFMgPSBTeW1ib2woJ0JvZHkgaW50ZXJuYWxzJyk7XHJcblxyXG4vLyBmaXggYW4gaXNzdWUgd2hlcmUgXCJQYXNzVGhyb3VnaFwiIGlzbid0IGEgbmFtZWQgZXhwb3J0IGZvciBub2RlIDwxMFxyXG5jb25zdCBQYXNzVGhyb3VnaCA9IFN0cmVhbS5QYXNzVGhyb3VnaDtcclxuXHJcbi8qKlxyXG4gKiBCb2R5IG1peGluXHJcbiAqXHJcbiAqIFJlZjogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2JvZHlcclxuICpcclxuICogQHBhcmFtICAgU3RyZWFtICBib2R5ICBSZWFkYWJsZSBzdHJlYW1cclxuICogQHBhcmFtICAgT2JqZWN0ICBvcHRzICBSZXNwb25zZSBvcHRpb25zXHJcbiAqIEByZXR1cm4gIFZvaWRcclxuICovXHJcbmZ1bmN0aW9uIEJvZHkoYm9keSkge1xyXG5cdHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG5cdHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcclxuXHQgICAgX3JlZiRzaXplID0gX3JlZi5zaXplO1xyXG5cclxuXHRsZXQgc2l6ZSA9IF9yZWYkc2l6ZSA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkc2l6ZTtcclxuXHR2YXIgX3JlZiR0aW1lb3V0ID0gX3JlZi50aW1lb3V0O1xyXG5cdGxldCB0aW1lb3V0ID0gX3JlZiR0aW1lb3V0ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR0aW1lb3V0O1xyXG5cclxuXHRpZiAoYm9keSA9PSBudWxsKSB7XHJcblx0XHQvLyBib2R5IGlzIHVuZGVmaW5lZCBvciBudWxsXHJcblx0XHRib2R5ID0gbnVsbDtcclxuXHR9IGVsc2UgaWYgKGlzVVJMU2VhcmNoUGFyYW1zKGJvZHkpKSB7XHJcblx0XHQvLyBib2R5IGlzIGEgVVJMU2VhcmNoUGFyYW1zXHJcblx0XHRib2R5ID0gQnVmZmVyLmZyb20oYm9keS50b1N0cmluZygpKTtcclxuXHR9IGVsc2UgaWYgKGlzQmxvYihib2R5KSkgOyBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoYm9keSkpIDsgZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJvZHkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XHJcblx0XHQvLyBib2R5IGlzIEFycmF5QnVmZmVyXHJcblx0XHRib2R5ID0gQnVmZmVyLmZyb20oYm9keSk7XHJcblx0fSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYm9keSkpIHtcclxuXHRcdC8vIGJvZHkgaXMgQXJyYXlCdWZmZXJWaWV3XHJcblx0XHRib2R5ID0gQnVmZmVyLmZyb20oYm9keS5idWZmZXIsIGJvZHkuYnl0ZU9mZnNldCwgYm9keS5ieXRlTGVuZ3RoKTtcclxuXHR9IGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBTdHJlYW0pIDsgZWxzZSB7XHJcblx0XHQvLyBub25lIG9mIHRoZSBhYm92ZVxyXG5cdFx0Ly8gY29lcmNlIHRvIHN0cmluZyB0aGVuIGJ1ZmZlclxyXG5cdFx0Ym9keSA9IEJ1ZmZlci5mcm9tKFN0cmluZyhib2R5KSk7XHJcblx0fVxyXG5cdHRoaXNbSU5URVJOQUxTXSA9IHtcclxuXHRcdGJvZHksXHJcblx0XHRkaXN0dXJiZWQ6IGZhbHNlLFxyXG5cdFx0ZXJyb3I6IG51bGxcclxuXHR9O1xyXG5cdHRoaXMuc2l6ZSA9IHNpemU7XHJcblx0dGhpcy50aW1lb3V0ID0gdGltZW91dDtcclxuXHJcblx0aWYgKGJvZHkgaW5zdGFuY2VvZiBTdHJlYW0pIHtcclxuXHRcdGJvZHkub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xyXG5cdFx0XHRjb25zdCBlcnJvciA9IGVyci5uYW1lID09PSAnQWJvcnRFcnJvcicgPyBlcnIgOiBuZXcgRmV0Y2hFcnJvcihgSW52YWxpZCByZXNwb25zZSBib2R5IHdoaWxlIHRyeWluZyB0byBmZXRjaCAke190aGlzLnVybH06ICR7ZXJyLm1lc3NhZ2V9YCwgJ3N5c3RlbScsIGVycik7XHJcblx0XHRcdF90aGlzW0lOVEVSTkFMU10uZXJyb3IgPSBlcnJvcjtcclxuXHRcdH0pO1xyXG5cdH1cclxufVxyXG5cclxuQm9keS5wcm90b3R5cGUgPSB7XHJcblx0Z2V0IGJvZHkoKSB7XHJcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLmJvZHk7XHJcblx0fSxcclxuXHJcblx0Z2V0IGJvZHlVc2VkKCkge1xyXG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5kaXN0dXJiZWQ7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcbiAgKiBEZWNvZGUgcmVzcG9uc2UgYXMgQXJyYXlCdWZmZXJcclxuICAqXHJcbiAgKiBAcmV0dXJuICBQcm9taXNlXHJcbiAgKi9cclxuXHRhcnJheUJ1ZmZlcigpIHtcclxuXHRcdHJldHVybiBjb25zdW1lQm9keS5jYWxsKHRoaXMpLnRoZW4oZnVuY3Rpb24gKGJ1Zikge1xyXG5cdFx0XHRyZXR1cm4gYnVmLmJ1ZmZlci5zbGljZShidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVPZmZzZXQgKyBidWYuYnl0ZUxlbmd0aCk7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuICAqIFJldHVybiByYXcgcmVzcG9uc2UgYXMgQmxvYlxyXG4gICpcclxuICAqIEByZXR1cm4gUHJvbWlzZVxyXG4gICovXHJcblx0YmxvYigpIHtcclxuXHRcdGxldCBjdCA9IHRoaXMuaGVhZGVycyAmJiB0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSB8fCAnJztcclxuXHRcdHJldHVybiBjb25zdW1lQm9keS5jYWxsKHRoaXMpLnRoZW4oZnVuY3Rpb24gKGJ1Zikge1xyXG5cdFx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnbihcclxuXHRcdFx0Ly8gUHJldmVudCBjb3B5aW5nXHJcblx0XHRcdG5ldyBCbG9iKFtdLCB7XHJcblx0XHRcdFx0dHlwZTogY3QudG9Mb3dlckNhc2UoKVxyXG5cdFx0XHR9KSwge1xyXG5cdFx0XHRcdFtCVUZGRVJdOiBidWZcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuICAqIERlY29kZSByZXNwb25zZSBhcyBqc29uXHJcbiAgKlxyXG4gICogQHJldHVybiAgUHJvbWlzZVxyXG4gICovXHJcblx0anNvbigpIHtcclxuXHRcdHZhciBfdGhpczIgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiBjb25zdW1lQm9keS5jYWxsKHRoaXMpLnRoZW4oZnVuY3Rpb24gKGJ1ZmZlcikge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdHJldHVybiBKU09OLnBhcnNlKGJ1ZmZlci50b1N0cmluZygpKTtcclxuXHRcdFx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRcdFx0cmV0dXJuIEJvZHkuUHJvbWlzZS5yZWplY3QobmV3IEZldGNoRXJyb3IoYGludmFsaWQganNvbiByZXNwb25zZSBib2R5IGF0ICR7X3RoaXMyLnVybH0gcmVhc29uOiAke2Vyci5tZXNzYWdlfWAsICdpbnZhbGlkLWpzb24nKSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG4gICogRGVjb2RlIHJlc3BvbnNlIGFzIHRleHRcclxuICAqXHJcbiAgKiBAcmV0dXJuICBQcm9taXNlXHJcbiAgKi9cclxuXHR0ZXh0KCkge1xyXG5cdFx0cmV0dXJuIGNvbnN1bWVCb2R5LmNhbGwodGhpcykudGhlbihmdW5jdGlvbiAoYnVmZmVyKSB7XHJcblx0XHRcdHJldHVybiBidWZmZXIudG9TdHJpbmcoKTtcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG4gICogRGVjb2RlIHJlc3BvbnNlIGFzIGJ1ZmZlciAobm9uLXNwZWMgYXBpKVxyXG4gICpcclxuICAqIEByZXR1cm4gIFByb21pc2VcclxuICAqL1xyXG5cdGJ1ZmZlcigpIHtcclxuXHRcdHJldHVybiBjb25zdW1lQm9keS5jYWxsKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG4gICogRGVjb2RlIHJlc3BvbnNlIGFzIHRleHQsIHdoaWxlIGF1dG9tYXRpY2FsbHkgZGV0ZWN0aW5nIHRoZSBlbmNvZGluZyBhbmRcclxuICAqIHRyeWluZyB0byBkZWNvZGUgdG8gVVRGLTggKG5vbi1zcGVjIGFwaSlcclxuICAqXHJcbiAgKiBAcmV0dXJuICBQcm9taXNlXHJcbiAgKi9cclxuXHR0ZXh0Q29udmVydGVkKCkge1xyXG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuIGNvbnN1bWVCb2R5LmNhbGwodGhpcykudGhlbihmdW5jdGlvbiAoYnVmZmVyKSB7XHJcblx0XHRcdHJldHVybiBjb252ZXJ0Qm9keShidWZmZXIsIF90aGlzMy5oZWFkZXJzKTtcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIEluIGJyb3dzZXJzLCBhbGwgcHJvcGVydGllcyBhcmUgZW51bWVyYWJsZS5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQm9keS5wcm90b3R5cGUsIHtcclxuXHRib2R5OiB7IGVudW1lcmFibGU6IHRydWUgfSxcclxuXHRib2R5VXNlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcblx0YXJyYXlCdWZmZXI6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxyXG5cdGJsb2I6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxyXG5cdGpzb246IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxyXG5cdHRleHQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XHJcbn0pO1xyXG5cclxuQm9keS5taXhJbiA9IGZ1bmN0aW9uIChwcm90bykge1xyXG5cdGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhCb2R5LnByb3RvdHlwZSkpIHtcclxuXHRcdC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBmdXR1cmUgcHJvb2ZcclxuXHRcdGlmICghKG5hbWUgaW4gcHJvdG8pKSB7XHJcblx0XHRcdGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEJvZHkucHJvdG90eXBlLCBuYW1lKTtcclxuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBuYW1lLCBkZXNjKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogQ29uc3VtZSBhbmQgY29udmVydCBhbiBlbnRpcmUgQm9keSB0byBhIEJ1ZmZlci5cclxuICpcclxuICogUmVmOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ib2R5LWNvbnN1bWUtYm9keVxyXG4gKlxyXG4gKiBAcmV0dXJuICBQcm9taXNlXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25zdW1lQm9keSgpIHtcclxuXHR2YXIgX3RoaXM0ID0gdGhpcztcclxuXHJcblx0aWYgKHRoaXNbSU5URVJOQUxTXS5kaXN0dXJiZWQpIHtcclxuXHRcdHJldHVybiBCb2R5LlByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoYGJvZHkgdXNlZCBhbHJlYWR5IGZvcjogJHt0aGlzLnVybH1gKSk7XHJcblx0fVxyXG5cclxuXHR0aGlzW0lOVEVSTkFMU10uZGlzdHVyYmVkID0gdHJ1ZTtcclxuXHJcblx0aWYgKHRoaXNbSU5URVJOQUxTXS5lcnJvcikge1xyXG5cdFx0cmV0dXJuIEJvZHkuUHJvbWlzZS5yZWplY3QodGhpc1tJTlRFUk5BTFNdLmVycm9yKTtcclxuXHR9XHJcblxyXG5cdGxldCBib2R5ID0gdGhpcy5ib2R5O1xyXG5cclxuXHQvLyBib2R5IGlzIG51bGxcclxuXHRpZiAoYm9keSA9PT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIEJvZHkuUHJvbWlzZS5yZXNvbHZlKEJ1ZmZlci5hbGxvYygwKSk7XHJcblx0fVxyXG5cclxuXHQvLyBib2R5IGlzIGJsb2JcclxuXHRpZiAoaXNCbG9iKGJvZHkpKSB7XHJcblx0XHRib2R5ID0gYm9keS5zdHJlYW0oKTtcclxuXHR9XHJcblxyXG5cdC8vIGJvZHkgaXMgYnVmZmVyXHJcblx0aWYgKEJ1ZmZlci5pc0J1ZmZlcihib2R5KSkge1xyXG5cdFx0cmV0dXJuIEJvZHkuUHJvbWlzZS5yZXNvbHZlKGJvZHkpO1xyXG5cdH1cclxuXHJcblx0Ly8gaXN0YW5idWwgaWdub3JlIGlmOiBzaG91bGQgbmV2ZXIgaGFwcGVuXHJcblx0aWYgKCEoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkpIHtcclxuXHRcdHJldHVybiBCb2R5LlByb21pc2UucmVzb2x2ZShCdWZmZXIuYWxsb2MoMCkpO1xyXG5cdH1cclxuXHJcblx0Ly8gYm9keSBpcyBzdHJlYW1cclxuXHQvLyBnZXQgcmVhZHkgdG8gYWN0dWFsbHkgY29uc3VtZSB0aGUgYm9keVxyXG5cdGxldCBhY2N1bSA9IFtdO1xyXG5cdGxldCBhY2N1bUJ5dGVzID0gMDtcclxuXHRsZXQgYWJvcnQgPSBmYWxzZTtcclxuXHJcblx0cmV0dXJuIG5ldyBCb2R5LlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG5cdFx0bGV0IHJlc1RpbWVvdXQ7XHJcblxyXG5cdFx0Ly8gYWxsb3cgdGltZW91dCBvbiBzbG93IHJlc3BvbnNlIGJvZHlcclxuXHRcdGlmIChfdGhpczQudGltZW91dCkge1xyXG5cdFx0XHRyZXNUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0YWJvcnQgPSB0cnVlO1xyXG5cdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgUmVzcG9uc2UgdGltZW91dCB3aGlsZSB0cnlpbmcgdG8gZmV0Y2ggJHtfdGhpczQudXJsfSAob3ZlciAke190aGlzNC50aW1lb3V0fW1zKWAsICdib2R5LXRpbWVvdXQnKSk7XHJcblx0XHRcdH0sIF90aGlzNC50aW1lb3V0KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBoYW5kbGUgc3RyZWFtIGVycm9yc1xyXG5cdFx0Ym9keS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XHJcblx0XHRcdGlmIChlcnIubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XHJcblx0XHRcdFx0Ly8gaWYgdGhlIHJlcXVlc3Qgd2FzIGFib3J0ZWQsIHJlamVjdCB3aXRoIHRoaXMgRXJyb3JcclxuXHRcdFx0XHRhYm9ydCA9IHRydWU7XHJcblx0XHRcdFx0cmVqZWN0KGVycik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gb3RoZXIgZXJyb3JzLCBzdWNoIGFzIGluY29ycmVjdCBjb250ZW50LWVuY29kaW5nXHJcblx0XHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKGBJbnZhbGlkIHJlc3BvbnNlIGJvZHkgd2hpbGUgdHJ5aW5nIHRvIGZldGNoICR7X3RoaXM0LnVybH06ICR7ZXJyLm1lc3NhZ2V9YCwgJ3N5c3RlbScsIGVycikpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRib2R5Lm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XHJcblx0XHRcdGlmIChhYm9ydCB8fCBjaHVuayA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKF90aGlzNC5zaXplICYmIGFjY3VtQnl0ZXMgKyBjaHVuay5sZW5ndGggPiBfdGhpczQuc2l6ZSkge1xyXG5cdFx0XHRcdGFib3J0ID0gdHJ1ZTtcclxuXHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoYGNvbnRlbnQgc2l6ZSBhdCAke190aGlzNC51cmx9IG92ZXIgbGltaXQ6ICR7X3RoaXM0LnNpemV9YCwgJ21heC1zaXplJykpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YWNjdW1CeXRlcyArPSBjaHVuay5sZW5ndGg7XHJcblx0XHRcdGFjY3VtLnB1c2goY2h1bmspO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ym9keS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAoYWJvcnQpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNsZWFyVGltZW91dChyZXNUaW1lb3V0KTtcclxuXHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0cmVzb2x2ZShCdWZmZXIuY29uY2F0KGFjY3VtLCBhY2N1bUJ5dGVzKSk7XHJcblx0XHRcdH0gY2F0Y2ggKGVycikge1xyXG5cdFx0XHRcdC8vIGhhbmRsZSBzdHJlYW1zIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0b28gbXVjaCBkYXRhIChpc3N1ZSAjNDE0KVxyXG5cdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgQ291bGQgbm90IGNyZWF0ZSBCdWZmZXIgZnJvbSByZXNwb25zZSBib2R5IGZvciAke190aGlzNC51cmx9OiAke2Vyci5tZXNzYWdlfWAsICdzeXN0ZW0nLCBlcnIpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXRlY3QgYnVmZmVyIGVuY29kaW5nIGFuZCBjb252ZXJ0IHRvIHRhcmdldCBlbmNvZGluZ1xyXG4gKiByZWY6IGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvV0QtaHRtbDUtMjAxMTAxMTMvcGFyc2luZy5odG1sI2RldGVybWluaW5nLXRoZS1jaGFyYWN0ZXItZW5jb2RpbmdcclxuICpcclxuICogQHBhcmFtICAgQnVmZmVyICBidWZmZXIgICAgSW5jb21pbmcgYnVmZmVyXHJcbiAqIEBwYXJhbSAgIFN0cmluZyAgZW5jb2RpbmcgIFRhcmdldCBlbmNvZGluZ1xyXG4gKiBAcmV0dXJuICBTdHJpbmdcclxuICovXHJcbmZ1bmN0aW9uIGNvbnZlcnRCb2R5KGJ1ZmZlciwgaGVhZGVycykge1xyXG5cdGlmICh0eXBlb2YgY29udmVydCAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgcGFja2FnZSBgZW5jb2RpbmdgIG11c3QgYmUgaW5zdGFsbGVkIHRvIHVzZSB0aGUgdGV4dENvbnZlcnRlZCgpIGZ1bmN0aW9uJyk7XHJcblx0fVxyXG5cclxuXHRjb25zdCBjdCA9IGhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcclxuXHRsZXQgY2hhcnNldCA9ICd1dGYtOCc7XHJcblx0bGV0IHJlcywgc3RyO1xyXG5cclxuXHQvLyBoZWFkZXJcclxuXHRpZiAoY3QpIHtcclxuXHRcdHJlcyA9IC9jaGFyc2V0PShbXjtdKikvaS5leGVjKGN0KTtcclxuXHR9XHJcblxyXG5cdC8vIG5vIGNoYXJzZXQgaW4gY29udGVudCB0eXBlLCBwZWVrIGF0IHJlc3BvbnNlIGJvZHkgZm9yIGF0IG1vc3QgMTAyNCBieXRlc1xyXG5cdHN0ciA9IGJ1ZmZlci5zbGljZSgwLCAxMDI0KS50b1N0cmluZygpO1xyXG5cclxuXHQvLyBodG1sNVxyXG5cdGlmICghcmVzICYmIHN0cikge1xyXG5cdFx0cmVzID0gLzxtZXRhLis/Y2hhcnNldD0oWydcIl0pKC4rPylcXDEvaS5leGVjKHN0cik7XHJcblx0fVxyXG5cclxuXHQvLyBodG1sNFxyXG5cdGlmICghcmVzICYmIHN0cikge1xyXG5cdFx0cmVzID0gLzxtZXRhW1xcc10rP2h0dHAtZXF1aXY9KFsnXCJdKWNvbnRlbnQtdHlwZVxcMVtcXHNdKz9jb250ZW50PShbJ1wiXSkoLis/KVxcMi9pLmV4ZWMoc3RyKTtcclxuXHJcblx0XHRpZiAocmVzKSB7XHJcblx0XHRcdHJlcyA9IC9jaGFyc2V0PSguKikvaS5leGVjKHJlcy5wb3AoKSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyB4bWxcclxuXHRpZiAoIXJlcyAmJiBzdHIpIHtcclxuXHRcdHJlcyA9IC88XFw/eG1sLis/ZW5jb2Rpbmc9KFsnXCJdKSguKz8pXFwxL2kuZXhlYyhzdHIpO1xyXG5cdH1cclxuXHJcblx0Ly8gZm91bmQgY2hhcnNldFxyXG5cdGlmIChyZXMpIHtcclxuXHRcdGNoYXJzZXQgPSByZXMucG9wKCk7XHJcblxyXG5cdFx0Ly8gcHJldmVudCBkZWNvZGUgaXNzdWVzIHdoZW4gc2l0ZXMgdXNlIGluY29ycmVjdCBlbmNvZGluZ1xyXG5cdFx0Ly8gcmVmOiBodHRwczovL2hzaXZvbmVuLmZpL2VuY29kaW5nLW1lbnUvXHJcblx0XHRpZiAoY2hhcnNldCA9PT0gJ2diMjMxMicgfHwgY2hhcnNldCA9PT0gJ2diaycpIHtcclxuXHRcdFx0Y2hhcnNldCA9ICdnYjE4MDMwJztcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIHR1cm4gcmF3IGJ1ZmZlcnMgaW50byBhIHNpbmdsZSB1dGYtOCBidWZmZXJcclxuXHRyZXR1cm4gY29udmVydChidWZmZXIsICdVVEYtOCcsIGNoYXJzZXQpLnRvU3RyaW5nKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXRlY3QgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XHJcbiAqIHJlZjogaHR0cHM6Ly9naXRodWIuY29tL2JpdGlubi9ub2RlLWZldGNoL2lzc3Vlcy8yOTYjaXNzdWVjb21tZW50LTMwNzU5ODE0M1xyXG4gKlxyXG4gKiBAcGFyYW0gICBPYmplY3QgIG9iaiAgICAgT2JqZWN0IHRvIGRldGVjdCBieSB0eXBlIG9yIGJyYW5kXHJcbiAqIEByZXR1cm4gIFN0cmluZ1xyXG4gKi9cclxuZnVuY3Rpb24gaXNVUkxTZWFyY2hQYXJhbXMob2JqKSB7XHJcblx0Ly8gRHVjay10eXBpbmcgYXMgYSBuZWNlc3NhcnkgY29uZGl0aW9uLlxyXG5cdGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqLmFwcGVuZCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqLmRlbGV0ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqLmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqLmdldEFsbCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqLmhhcyAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqLnNldCAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0Ly8gQnJhbmQtY2hlY2tpbmcgYW5kIG1vcmUgZHVjay10eXBpbmcgYXMgb3B0aW9uYWwgY29uZGl0aW9uLlxyXG5cdHJldHVybiBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gJ1VSTFNlYXJjaFBhcmFtcycgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFVSTFNlYXJjaFBhcmFtc10nIHx8IHR5cGVvZiBvYmouc29ydCA9PT0gJ2Z1bmN0aW9uJztcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGEgVzNDIGBCbG9iYCBvYmplY3QgKHdoaWNoIGBGaWxlYCBpbmhlcml0cyBmcm9tKVxyXG4gKiBAcGFyYW0gIHsqfSBvYmpcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGlzQmxvYihvYmopIHtcclxuXHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iai5hcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnR5cGUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBvYmouc3RyZWFtID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSAnc3RyaW5nJyAmJiAvXihCbG9ifEZpbGUpJC8udGVzdChvYmouY29uc3RydWN0b3IubmFtZSkgJiYgL14oQmxvYnxGaWxlKSQvLnRlc3Qob2JqW1N5bWJvbC50b1N0cmluZ1RhZ10pO1xyXG59XHJcblxyXG4vKipcclxuICogQ2xvbmUgYm9keSBnaXZlbiBSZXMvUmVxIGluc3RhbmNlXHJcbiAqXHJcbiAqIEBwYXJhbSAgIE1peGVkICBpbnN0YW5jZSAgUmVzcG9uc2Ugb3IgUmVxdWVzdCBpbnN0YW5jZVxyXG4gKiBAcmV0dXJuICBNaXhlZFxyXG4gKi9cclxuZnVuY3Rpb24gY2xvbmUoaW5zdGFuY2UpIHtcclxuXHRsZXQgcDEsIHAyO1xyXG5cdGxldCBib2R5ID0gaW5zdGFuY2UuYm9keTtcclxuXHJcblx0Ly8gZG9uJ3QgYWxsb3cgY2xvbmluZyBhIHVzZWQgYm9keVxyXG5cdGlmIChpbnN0YW5jZS5ib2R5VXNlZCkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY2xvbmUgYm9keSBhZnRlciBpdCBpcyB1c2VkJyk7XHJcblx0fVxyXG5cclxuXHQvLyBjaGVjayB0aGF0IGJvZHkgaXMgYSBzdHJlYW0gYW5kIG5vdCBmb3JtLWRhdGEgb2JqZWN0XHJcblx0Ly8gbm90ZTogd2UgY2FuJ3QgY2xvbmUgdGhlIGZvcm0tZGF0YSBvYmplY3Qgd2l0aG91dCBoYXZpbmcgaXQgYXMgYSBkZXBlbmRlbmN5XHJcblx0aWYgKGJvZHkgaW5zdGFuY2VvZiBTdHJlYW0gJiYgdHlwZW9mIGJvZHkuZ2V0Qm91bmRhcnkgIT09ICdmdW5jdGlvbicpIHtcclxuXHRcdC8vIHRlZSBpbnN0YW5jZSBib2R5XHJcblx0XHRwMSA9IG5ldyBQYXNzVGhyb3VnaCgpO1xyXG5cdFx0cDIgPSBuZXcgUGFzc1Rocm91Z2goKTtcclxuXHRcdGJvZHkucGlwZShwMSk7XHJcblx0XHRib2R5LnBpcGUocDIpO1xyXG5cdFx0Ly8gc2V0IGluc3RhbmNlIGJvZHkgdG8gdGVlZCBib2R5IGFuZCByZXR1cm4gdGhlIG90aGVyIHRlZWQgYm9keVxyXG5cdFx0aW5zdGFuY2VbSU5URVJOQUxTXS5ib2R5ID0gcDE7XHJcblx0XHRib2R5ID0gcDI7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gYm9keTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBlcmZvcm1zIHRoZSBvcGVyYXRpb24gXCJleHRyYWN0IGEgYENvbnRlbnQtVHlwZWAgdmFsdWUgZnJvbSB8b2JqZWN0fFwiIGFzXHJcbiAqIHNwZWNpZmllZCBpbiB0aGUgc3BlY2lmaWNhdGlvbjpcclxuICogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keWluaXQtZXh0cmFjdFxyXG4gKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBpbnN0YW5jZS5ib2R5IGlzIHByZXNlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSAgIE1peGVkICBpbnN0YW5jZSAgQW55IG9wdGlvbnMuYm9keSBpbnB1dFxyXG4gKi9cclxuZnVuY3Rpb24gZXh0cmFjdENvbnRlbnRUeXBlKGJvZHkpIHtcclxuXHRpZiAoYm9keSA9PT0gbnVsbCkge1xyXG5cdFx0Ly8gYm9keSBpcyBudWxsXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xyXG5cdFx0Ly8gYm9keSBpcyBzdHJpbmdcclxuXHRcdHJldHVybiAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04JztcclxuXHR9IGVsc2UgaWYgKGlzVVJMU2VhcmNoUGFyYW1zKGJvZHkpKSB7XHJcblx0XHQvLyBib2R5IGlzIGEgVVJMU2VhcmNoUGFyYW1zXHJcblx0XHRyZXR1cm4gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04JztcclxuXHR9IGVsc2UgaWYgKGlzQmxvYihib2R5KSkge1xyXG5cdFx0Ly8gYm9keSBpcyBibG9iXHJcblx0XHRyZXR1cm4gYm9keS50eXBlIHx8IG51bGw7XHJcblx0fSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoYm9keSkpIHtcclxuXHRcdC8vIGJvZHkgaXMgYnVmZmVyXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChib2R5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xyXG5cdFx0Ly8gYm9keSBpcyBBcnJheUJ1ZmZlclxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYm9keSkpIHtcclxuXHRcdC8vIGJvZHkgaXMgQXJyYXlCdWZmZXJWaWV3XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9IGVsc2UgaWYgKHR5cGVvZiBib2R5LmdldEJvdW5kYXJ5ID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHQvLyBkZXRlY3QgZm9ybSBkYXRhIGlucHV0IGZyb20gZm9ybS1kYXRhIG1vZHVsZVxyXG5cdFx0cmV0dXJuIGBtdWx0aXBhcnQvZm9ybS1kYXRhO2JvdW5kYXJ5PSR7Ym9keS5nZXRCb3VuZGFyeSgpfWA7XHJcblx0fSBlbHNlIGlmIChib2R5IGluc3RhbmNlb2YgU3RyZWFtKSB7XHJcblx0XHQvLyBib2R5IGlzIHN0cmVhbVxyXG5cdFx0Ly8gY2FuJ3QgcmVhbGx5IGRvIG11Y2ggYWJvdXQgdGhpc1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fSBlbHNlIHtcclxuXHRcdC8vIEJvZHkgY29uc3RydWN0b3IgZGVmYXVsdHMgb3RoZXIgdGhpbmdzIHRvIHN0cmluZ1xyXG5cdFx0cmV0dXJuICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnO1xyXG5cdH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBGZXRjaCBTdGFuZGFyZCB0cmVhdHMgdGhpcyBhcyBpZiBcInRvdGFsIGJ5dGVzXCIgaXMgYSBwcm9wZXJ0eSBvbiB0aGUgYm9keS5cclxuICogRm9yIHVzLCB3ZSBoYXZlIHRvIGV4cGxpY2l0bHkgZ2V0IGl0IHdpdGggYSBmdW5jdGlvbi5cclxuICpcclxuICogcmVmOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ib2R5LXRvdGFsLWJ5dGVzXHJcbiAqXHJcbiAqIEBwYXJhbSAgIEJvZHkgICAgaW5zdGFuY2UgICBJbnN0YW5jZSBvZiBCb2R5XHJcbiAqIEByZXR1cm4gIE51bWJlcj8gICAgICAgICAgICBOdW1iZXIgb2YgYnl0ZXMsIG9yIG51bGwgaWYgbm90IHBvc3NpYmxlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRUb3RhbEJ5dGVzKGluc3RhbmNlKSB7XHJcblx0Y29uc3QgYm9keSA9IGluc3RhbmNlLmJvZHk7XHJcblxyXG5cclxuXHRpZiAoYm9keSA9PT0gbnVsbCkge1xyXG5cdFx0Ly8gYm9keSBpcyBudWxsXHJcblx0XHRyZXR1cm4gMDtcclxuXHR9IGVsc2UgaWYgKGlzQmxvYihib2R5KSkge1xyXG5cdFx0cmV0dXJuIGJvZHkuc2l6ZTtcclxuXHR9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihib2R5KSkge1xyXG5cdFx0Ly8gYm9keSBpcyBidWZmZXJcclxuXHRcdHJldHVybiBib2R5Lmxlbmd0aDtcclxuXHR9IGVsc2UgaWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkuZ2V0TGVuZ3RoU3luYyA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0Ly8gZGV0ZWN0IGZvcm0gZGF0YSBpbnB1dCBmcm9tIGZvcm0tZGF0YSBtb2R1bGVcclxuXHRcdGlmIChib2R5Ll9sZW5ndGhSZXRyaWV2ZXJzICYmIGJvZHkuX2xlbmd0aFJldHJpZXZlcnMubGVuZ3RoID09IDAgfHwgLy8gMS54XHJcblx0XHRib2R5Lmhhc0tub3duTGVuZ3RoICYmIGJvZHkuaGFzS25vd25MZW5ndGgoKSkge1xyXG5cdFx0XHQvLyAyLnhcclxuXHRcdFx0cmV0dXJuIGJvZHkuZ2V0TGVuZ3RoU3luYygpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fSBlbHNlIHtcclxuXHRcdC8vIGJvZHkgaXMgc3RyZWFtXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXcml0ZSBhIEJvZHkgdG8gYSBOb2RlLmpzIFdyaXRhYmxlU3RyZWFtIChlLmcuIGh0dHAuUmVxdWVzdCkgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0gICBCb2R5ICAgIGluc3RhbmNlICAgSW5zdGFuY2Ugb2YgQm9keVxyXG4gKiBAcmV0dXJuICBWb2lkXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRvU3RyZWFtKGRlc3QsIGluc3RhbmNlKSB7XHJcblx0Y29uc3QgYm9keSA9IGluc3RhbmNlLmJvZHk7XHJcblxyXG5cclxuXHRpZiAoYm9keSA9PT0gbnVsbCkge1xyXG5cdFx0Ly8gYm9keSBpcyBudWxsXHJcblx0XHRkZXN0LmVuZCgpO1xyXG5cdH0gZWxzZSBpZiAoaXNCbG9iKGJvZHkpKSB7XHJcblx0XHRib2R5LnN0cmVhbSgpLnBpcGUoZGVzdCk7XHJcblx0fSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoYm9keSkpIHtcclxuXHRcdC8vIGJvZHkgaXMgYnVmZmVyXHJcblx0XHRkZXN0LndyaXRlKGJvZHkpO1xyXG5cdFx0ZGVzdC5lbmQoKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gYm9keSBpcyBzdHJlYW1cclxuXHRcdGJvZHkucGlwZShkZXN0KTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIGV4cG9zZSBQcm9taXNlXHJcbkJvZHkuUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xyXG5cclxuLyoqXHJcbiAqIGhlYWRlcnMuanNcclxuICpcclxuICogSGVhZGVycyBjbGFzcyBvZmZlcnMgY29udmVuaWVudCBoZWxwZXJzXHJcbiAqL1xyXG5cclxuY29uc3QgaW52YWxpZFRva2VuUmVnZXggPSAvW15cXF5fYGEtekEtWlxcLTAtOSEjJCUmJyorLnx+XS87XHJcbmNvbnN0IGludmFsaWRIZWFkZXJDaGFyUmVnZXggPSAvW15cXHRcXHgyMC1cXHg3ZVxceDgwLVxceGZmXS87XHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZU5hbWUobmFtZSkge1xyXG5cdG5hbWUgPSBgJHtuYW1lfWA7XHJcblx0aWYgKGludmFsaWRUb2tlblJlZ2V4LnRlc3QobmFtZSkgfHwgbmFtZSA9PT0gJycpIHtcclxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYCR7bmFtZX0gaXMgbm90IGEgbGVnYWwgSFRUUCBoZWFkZXIgbmFtZWApO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGVWYWx1ZSh2YWx1ZSkge1xyXG5cdHZhbHVlID0gYCR7dmFsdWV9YDtcclxuXHRpZiAoaW52YWxpZEhlYWRlckNoYXJSZWdleC50ZXN0KHZhbHVlKSkge1xyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgJHt2YWx1ZX0gaXMgbm90IGEgbGVnYWwgSFRUUCBoZWFkZXIgdmFsdWVgKTtcclxuXHR9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGaW5kIHRoZSBrZXkgaW4gdGhlIG1hcCBvYmplY3QgZ2l2ZW4gYSBoZWFkZXIgbmFtZS5cclxuICpcclxuICogUmV0dXJucyB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxyXG4gKlxyXG4gKiBAcGFyYW0gICBTdHJpbmcgIG5hbWUgIEhlYWRlciBuYW1lXHJcbiAqIEByZXR1cm4gIFN0cmluZ3xVbmRlZmluZWRcclxuICovXHJcbmZ1bmN0aW9uIGZpbmQobWFwLCBuYW1lKSB7XHJcblx0bmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHRmb3IgKGNvbnN0IGtleSBpbiBtYXApIHtcclxuXHRcdGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSkge1xyXG5cdFx0XHRyZXR1cm4ga2V5O1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcblxyXG5jb25zdCBNQVAgPSBTeW1ib2woJ21hcCcpO1xyXG5jbGFzcyBIZWFkZXJzIHtcclxuXHQvKipcclxuICAqIEhlYWRlcnMgY2xhc3NcclxuICAqXHJcbiAgKiBAcGFyYW0gICBPYmplY3QgIGhlYWRlcnMgIFJlc3BvbnNlIGhlYWRlcnNcclxuICAqIEByZXR1cm4gIFZvaWRcclxuICAqL1xyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cdFx0bGV0IGluaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZDtcclxuXHJcblx0XHR0aGlzW01BUF0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cclxuXHRcdGlmIChpbml0IGluc3RhbmNlb2YgSGVhZGVycykge1xyXG5cdFx0XHRjb25zdCByYXdIZWFkZXJzID0gaW5pdC5yYXcoKTtcclxuXHRcdFx0Y29uc3QgaGVhZGVyTmFtZXMgPSBPYmplY3Qua2V5cyhyYXdIZWFkZXJzKTtcclxuXHJcblx0XHRcdGZvciAoY29uc3QgaGVhZGVyTmFtZSBvZiBoZWFkZXJOYW1lcykge1xyXG5cdFx0XHRcdGZvciAoY29uc3QgdmFsdWUgb2YgcmF3SGVhZGVyc1toZWFkZXJOYW1lXSkge1xyXG5cdFx0XHRcdFx0dGhpcy5hcHBlbmQoaGVhZGVyTmFtZSwgdmFsdWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFdlIGRvbid0IHdvcnJ5IGFib3V0IGNvbnZlcnRpbmcgcHJvcCB0byBCeXRlU3RyaW5nIGhlcmUgYXMgYXBwZW5kKClcclxuXHRcdC8vIHdpbGwgaGFuZGxlIGl0LlxyXG5cdFx0aWYgKGluaXQgPT0gbnVsbCkgOyBlbHNlIGlmICh0eXBlb2YgaW5pdCA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Y29uc3QgbWV0aG9kID0gaW5pdFtTeW1ib2wuaXRlcmF0b3JdO1xyXG5cdFx0XHRpZiAobWV0aG9kICE9IG51bGwpIHtcclxuXHRcdFx0XHRpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignSGVhZGVyIHBhaXJzIG11c3QgYmUgaXRlcmFibGUnKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIHNlcXVlbmNlPHNlcXVlbmNlPEJ5dGVTdHJpbmc+PlxyXG5cdFx0XHRcdC8vIE5vdGU6IHBlciBzcGVjIHdlIGhhdmUgdG8gZmlyc3QgZXhoYXVzdCB0aGUgbGlzdHMgdGhlbiBwcm9jZXNzIHRoZW1cclxuXHRcdFx0XHRjb25zdCBwYWlycyA9IFtdO1xyXG5cdFx0XHRcdGZvciAoY29uc3QgcGFpciBvZiBpbml0KSB7XHJcblx0XHRcdFx0XHRpZiAodHlwZW9mIHBhaXIgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYWlyW1N5bWJvbC5pdGVyYXRvcl0gIT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRWFjaCBoZWFkZXIgcGFpciBtdXN0IGJlIGl0ZXJhYmxlJyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRwYWlycy5wdXNoKEFycmF5LmZyb20ocGFpcikpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XHJcblx0XHRcdFx0XHRpZiAocGFpci5sZW5ndGggIT09IDIpIHtcclxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRWFjaCBoZWFkZXIgcGFpciBtdXN0IGJlIGEgbmFtZS92YWx1ZSB0dXBsZScpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGhpcy5hcHBlbmQocGFpclswXSwgcGFpclsxXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIHJlY29yZDxCeXRlU3RyaW5nLCBCeXRlU3RyaW5nPlxyXG5cdFx0XHRcdGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGluaXQpKSB7XHJcblx0XHRcdFx0XHRjb25zdCB2YWx1ZSA9IGluaXRba2V5XTtcclxuXHRcdFx0XHRcdHRoaXMuYXBwZW5kKGtleSwgdmFsdWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignUHJvdmlkZWQgaW5pdGlhbGl6ZXIgbXVzdCBiZSBhbiBvYmplY3QnKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG4gICogUmV0dXJuIGNvbWJpbmVkIGhlYWRlciB2YWx1ZSBnaXZlbiBuYW1lXHJcbiAgKlxyXG4gICogQHBhcmFtICAgU3RyaW5nICBuYW1lICBIZWFkZXIgbmFtZVxyXG4gICogQHJldHVybiAgTWl4ZWRcclxuICAqL1xyXG5cdGdldChuYW1lKSB7XHJcblx0XHRuYW1lID0gYCR7bmFtZX1gO1xyXG5cdFx0dmFsaWRhdGVOYW1lKG5hbWUpO1xyXG5cdFx0Y29uc3Qga2V5ID0gZmluZCh0aGlzW01BUF0sIG5hbWUpO1xyXG5cdFx0aWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzW01BUF1ba2V5XS5qb2luKCcsICcpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcbiAgKiBJdGVyYXRlIG92ZXIgYWxsIGhlYWRlcnNcclxuICAqXHJcbiAgKiBAcGFyYW0gICBGdW5jdGlvbiAgY2FsbGJhY2sgIEV4ZWN1dGVkIGZvciBlYWNoIGl0ZW0gd2l0aCBwYXJhbWV0ZXJzICh2YWx1ZSwgbmFtZSwgdGhpc0FyZylcclxuICAqIEBwYXJhbSAgIEJvb2xlYW4gICB0aGlzQXJnICAgYHRoaXNgIGNvbnRleHQgZm9yIGNhbGxiYWNrIGZ1bmN0aW9uXHJcbiAgKiBAcmV0dXJuICBWb2lkXHJcbiAgKi9cclxuXHRmb3JFYWNoKGNhbGxiYWNrKSB7XHJcblx0XHRsZXQgdGhpc0FyZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xyXG5cclxuXHRcdGxldCBwYWlycyA9IGdldEhlYWRlcnModGhpcyk7XHJcblx0XHRsZXQgaSA9IDA7XHJcblx0XHR3aGlsZSAoaSA8IHBhaXJzLmxlbmd0aCkge1xyXG5cdFx0XHR2YXIgX3BhaXJzJGkgPSBwYWlyc1tpXTtcclxuXHRcdFx0Y29uc3QgbmFtZSA9IF9wYWlycyRpWzBdLFxyXG5cdFx0XHQgICAgICB2YWx1ZSA9IF9wYWlycyRpWzFdO1xyXG5cclxuXHRcdFx0Y2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWx1ZSwgbmFtZSwgdGhpcyk7XHJcblx0XHRcdHBhaXJzID0gZ2V0SGVhZGVycyh0aGlzKTtcclxuXHRcdFx0aSsrO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcbiAgKiBPdmVyd3JpdGUgaGVhZGVyIHZhbHVlcyBnaXZlbiBuYW1lXHJcbiAgKlxyXG4gICogQHBhcmFtICAgU3RyaW5nICBuYW1lICAgSGVhZGVyIG5hbWVcclxuICAqIEBwYXJhbSAgIFN0cmluZyAgdmFsdWUgIEhlYWRlciB2YWx1ZVxyXG4gICogQHJldHVybiAgVm9pZFxyXG4gICovXHJcblx0c2V0KG5hbWUsIHZhbHVlKSB7XHJcblx0XHRuYW1lID0gYCR7bmFtZX1gO1xyXG5cdFx0dmFsdWUgPSBgJHt2YWx1ZX1gO1xyXG5cdFx0dmFsaWRhdGVOYW1lKG5hbWUpO1xyXG5cdFx0dmFsaWRhdGVWYWx1ZSh2YWx1ZSk7XHJcblx0XHRjb25zdCBrZXkgPSBmaW5kKHRoaXNbTUFQXSwgbmFtZSk7XHJcblx0XHR0aGlzW01BUF1ba2V5ICE9PSB1bmRlZmluZWQgPyBrZXkgOiBuYW1lXSA9IFt2YWx1ZV07XHJcblx0fVxyXG5cclxuXHQvKipcclxuICAqIEFwcGVuZCBhIHZhbHVlIG9udG8gZXhpc3RpbmcgaGVhZGVyXHJcbiAgKlxyXG4gICogQHBhcmFtICAgU3RyaW5nICBuYW1lICAgSGVhZGVyIG5hbWVcclxuICAqIEBwYXJhbSAgIFN0cmluZyAgdmFsdWUgIEhlYWRlciB2YWx1ZVxyXG4gICogQHJldHVybiAgVm9pZFxyXG4gICovXHJcblx0YXBwZW5kKG5hbWUsIHZhbHVlKSB7XHJcblx0XHRuYW1lID0gYCR7bmFtZX1gO1xyXG5cdFx0dmFsdWUgPSBgJHt2YWx1ZX1gO1xyXG5cdFx0dmFsaWRhdGVOYW1lKG5hbWUpO1xyXG5cdFx0dmFsaWRhdGVWYWx1ZSh2YWx1ZSk7XHJcblx0XHRjb25zdCBrZXkgPSBmaW5kKHRoaXNbTUFQXSwgbmFtZSk7XHJcblx0XHRpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpc1tNQVBdW2tleV0ucHVzaCh2YWx1ZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzW01BUF1bbmFtZV0gPSBbdmFsdWVdO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcbiAgKiBDaGVjayBmb3IgaGVhZGVyIG5hbWUgZXhpc3RlbmNlXHJcbiAgKlxyXG4gICogQHBhcmFtICAgU3RyaW5nICAgbmFtZSAgSGVhZGVyIG5hbWVcclxuICAqIEByZXR1cm4gIEJvb2xlYW5cclxuICAqL1xyXG5cdGhhcyhuYW1lKSB7XHJcblx0XHRuYW1lID0gYCR7bmFtZX1gO1xyXG5cdFx0dmFsaWRhdGVOYW1lKG5hbWUpO1xyXG5cdFx0cmV0dXJuIGZpbmQodGhpc1tNQVBdLCBuYW1lKSAhPT0gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcbiAgKiBEZWxldGUgYWxsIGhlYWRlciB2YWx1ZXMgZ2l2ZW4gbmFtZVxyXG4gICpcclxuICAqIEBwYXJhbSAgIFN0cmluZyAgbmFtZSAgSGVhZGVyIG5hbWVcclxuICAqIEByZXR1cm4gIFZvaWRcclxuICAqL1xyXG5cdGRlbGV0ZShuYW1lKSB7XHJcblx0XHRuYW1lID0gYCR7bmFtZX1gO1xyXG5cdFx0dmFsaWRhdGVOYW1lKG5hbWUpO1xyXG5cdFx0Y29uc3Qga2V5ID0gZmluZCh0aGlzW01BUF0sIG5hbWUpO1xyXG5cdFx0aWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGRlbGV0ZSB0aGlzW01BUF1ba2V5XTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG4gICogUmV0dXJuIHJhdyBoZWFkZXJzIChub24tc3BlYyBhcGkpXHJcbiAgKlxyXG4gICogQHJldHVybiAgT2JqZWN0XHJcbiAgKi9cclxuXHRyYXcoKSB7XHJcblx0XHRyZXR1cm4gdGhpc1tNQVBdO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcbiAgKiBHZXQgYW4gaXRlcmF0b3Igb24ga2V5cy5cclxuICAqXHJcbiAgKiBAcmV0dXJuICBJdGVyYXRvclxyXG4gICovXHJcblx0a2V5cygpIHtcclxuXHRcdHJldHVybiBjcmVhdGVIZWFkZXJzSXRlcmF0b3IodGhpcywgJ2tleScpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcbiAgKiBHZXQgYW4gaXRlcmF0b3Igb24gdmFsdWVzLlxyXG4gICpcclxuICAqIEByZXR1cm4gIEl0ZXJhdG9yXHJcbiAgKi9cclxuXHR2YWx1ZXMoKSB7XHJcblx0XHRyZXR1cm4gY3JlYXRlSGVhZGVyc0l0ZXJhdG9yKHRoaXMsICd2YWx1ZScpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcbiAgKiBHZXQgYW4gaXRlcmF0b3Igb24gZW50cmllcy5cclxuICAqXHJcbiAgKiBUaGlzIGlzIHRoZSBkZWZhdWx0IGl0ZXJhdG9yIG9mIHRoZSBIZWFkZXJzIG9iamVjdC5cclxuICAqXHJcbiAgKiBAcmV0dXJuICBJdGVyYXRvclxyXG4gICovXHJcblx0W1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcblx0XHRyZXR1cm4gY3JlYXRlSGVhZGVyc0l0ZXJhdG9yKHRoaXMsICdrZXkrdmFsdWUnKTtcclxuXHR9XHJcbn1cclxuSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSGVhZGVycy5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xyXG5cdHZhbHVlOiAnSGVhZGVycycsXHJcblx0d3JpdGFibGU6IGZhbHNlLFxyXG5cdGVudW1lcmFibGU6IGZhbHNlLFxyXG5cdGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG59KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEhlYWRlcnMucHJvdG90eXBlLCB7XHJcblx0Z2V0OiB7IGVudW1lcmFibGU6IHRydWUgfSxcclxuXHRmb3JFYWNoOiB7IGVudW1lcmFibGU6IHRydWUgfSxcclxuXHRzZXQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxyXG5cdGFwcGVuZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcblx0aGFzOiB7IGVudW1lcmFibGU6IHRydWUgfSxcclxuXHRkZWxldGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxyXG5cdGtleXM6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxyXG5cdHZhbHVlczogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcblx0ZW50cmllczogeyBlbnVtZXJhYmxlOiB0cnVlIH1cclxufSk7XHJcblxyXG5mdW5jdGlvbiBnZXRIZWFkZXJzKGhlYWRlcnMpIHtcclxuXHRsZXQga2luZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ2tleSt2YWx1ZSc7XHJcblxyXG5cdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzW01BUF0pLnNvcnQoKTtcclxuXHRyZXR1cm4ga2V5cy5tYXAoa2luZCA9PT0gJ2tleScgPyBmdW5jdGlvbiAoaykge1xyXG5cdFx0cmV0dXJuIGsudG9Mb3dlckNhc2UoKTtcclxuXHR9IDoga2luZCA9PT0gJ3ZhbHVlJyA/IGZ1bmN0aW9uIChrKSB7XHJcblx0XHRyZXR1cm4gaGVhZGVyc1tNQVBdW2tdLmpvaW4oJywgJyk7XHJcblx0fSA6IGZ1bmN0aW9uIChrKSB7XHJcblx0XHRyZXR1cm4gW2sudG9Mb3dlckNhc2UoKSwgaGVhZGVyc1tNQVBdW2tdLmpvaW4oJywgJyldO1xyXG5cdH0pO1xyXG59XHJcblxyXG5jb25zdCBJTlRFUk5BTCA9IFN5bWJvbCgnaW50ZXJuYWwnKTtcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUhlYWRlcnNJdGVyYXRvcih0YXJnZXQsIGtpbmQpIHtcclxuXHRjb25zdCBpdGVyYXRvciA9IE9iamVjdC5jcmVhdGUoSGVhZGVyc0l0ZXJhdG9yUHJvdG90eXBlKTtcclxuXHRpdGVyYXRvcltJTlRFUk5BTF0gPSB7XHJcblx0XHR0YXJnZXQsXHJcblx0XHRraW5kLFxyXG5cdFx0aW5kZXg6IDBcclxuXHR9O1xyXG5cdHJldHVybiBpdGVyYXRvcjtcclxufVxyXG5cclxuY29uc3QgSGVhZGVyc0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LnNldFByb3RvdHlwZU9mKHtcclxuXHRuZXh0KCkge1xyXG5cdFx0Ly8gaXN0YW5idWwgaWdub3JlIGlmXHJcblx0XHRpZiAoIXRoaXMgfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpICE9PSBIZWFkZXJzSXRlcmF0b3JQcm90b3R5cGUpIHtcclxuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignVmFsdWUgb2YgYHRoaXNgIGlzIG5vdCBhIEhlYWRlcnNJdGVyYXRvcicpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBfSU5URVJOQUwgPSB0aGlzW0lOVEVSTkFMXTtcclxuXHRcdGNvbnN0IHRhcmdldCA9IF9JTlRFUk5BTC50YXJnZXQsXHJcblx0XHQgICAgICBraW5kID0gX0lOVEVSTkFMLmtpbmQsXHJcblx0XHQgICAgICBpbmRleCA9IF9JTlRFUk5BTC5pbmRleDtcclxuXHJcblx0XHRjb25zdCB2YWx1ZXMgPSBnZXRIZWFkZXJzKHRhcmdldCwga2luZCk7XHJcblx0XHRjb25zdCBsZW4gPSB2YWx1ZXMubGVuZ3RoO1xyXG5cdFx0aWYgKGluZGV4ID49IGxlbikge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHZhbHVlOiB1bmRlZmluZWQsXHJcblx0XHRcdFx0ZG9uZTogdHJ1ZVxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXNbSU5URVJOQUxdLmluZGV4ID0gaW5kZXggKyAxO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHZhbHVlOiB2YWx1ZXNbaW5kZXhdLFxyXG5cdFx0XHRkb25lOiBmYWxzZVxyXG5cdFx0fTtcclxuXHR9XHJcbn0sIE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YoW11bU3ltYm9sLml0ZXJhdG9yXSgpKSkpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlYWRlcnNJdGVyYXRvclByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XHJcblx0dmFsdWU6ICdIZWFkZXJzSXRlcmF0b3InLFxyXG5cdHdyaXRhYmxlOiBmYWxzZSxcclxuXHRlbnVtZXJhYmxlOiBmYWxzZSxcclxuXHRjb25maWd1cmFibGU6IHRydWVcclxufSk7XHJcblxyXG4vKipcclxuICogRXhwb3J0IHRoZSBIZWFkZXJzIG9iamVjdCBpbiBhIGZvcm0gdGhhdCBOb2RlLmpzIGNhbiBjb25zdW1lLlxyXG4gKlxyXG4gKiBAcGFyYW0gICBIZWFkZXJzICBoZWFkZXJzXHJcbiAqIEByZXR1cm4gIE9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gZXhwb3J0Tm9kZUNvbXBhdGlibGVIZWFkZXJzKGhlYWRlcnMpIHtcclxuXHRjb25zdCBvYmogPSBPYmplY3QuYXNzaWduKHsgX19wcm90b19fOiBudWxsIH0sIGhlYWRlcnNbTUFQXSk7XHJcblxyXG5cdC8vIGh0dHAucmVxdWVzdCgpIG9ubHkgc3VwcG9ydHMgc3RyaW5nIGFzIEhvc3QgaGVhZGVyLiBUaGlzIGhhY2sgbWFrZXNcclxuXHQvLyBzcGVjaWZ5aW5nIGN1c3RvbSBIb3N0IGhlYWRlciBwb3NzaWJsZS5cclxuXHRjb25zdCBob3N0SGVhZGVyS2V5ID0gZmluZChoZWFkZXJzW01BUF0sICdIb3N0Jyk7XHJcblx0aWYgKGhvc3RIZWFkZXJLZXkgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0b2JqW2hvc3RIZWFkZXJLZXldID0gb2JqW2hvc3RIZWFkZXJLZXldWzBdO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIEhlYWRlcnMgb2JqZWN0IGZyb20gYW4gb2JqZWN0IG9mIGhlYWRlcnMsIGlnbm9yaW5nIHRob3NlIHRoYXQgZG9cclxuICogbm90IGNvbmZvcm0gdG8gSFRUUCBncmFtbWFyIHByb2R1Y3Rpb25zLlxyXG4gKlxyXG4gKiBAcGFyYW0gICBPYmplY3QgIG9iaiAgT2JqZWN0IG9mIGhlYWRlcnNcclxuICogQHJldHVybiAgSGVhZGVyc1xyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlSGVhZGVyc0xlbmllbnQob2JqKSB7XHJcblx0Y29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XHJcblx0Zm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKG9iaikpIHtcclxuXHRcdGlmIChpbnZhbGlkVG9rZW5SZWdleC50ZXN0KG5hbWUpKSB7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkob2JqW25hbWVdKSkge1xyXG5cdFx0XHRmb3IgKGNvbnN0IHZhbCBvZiBvYmpbbmFtZV0pIHtcclxuXHRcdFx0XHRpZiAoaW52YWxpZEhlYWRlckNoYXJSZWdleC50ZXN0KHZhbCkpIHtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoaGVhZGVyc1tNQVBdW25hbWVdID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdGhlYWRlcnNbTUFQXVtuYW1lXSA9IFt2YWxdO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRoZWFkZXJzW01BUF1bbmFtZV0ucHVzaCh2YWwpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmICghaW52YWxpZEhlYWRlckNoYXJSZWdleC50ZXN0KG9ialtuYW1lXSkpIHtcclxuXHRcdFx0aGVhZGVyc1tNQVBdW25hbWVdID0gW29ialtuYW1lXV07XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBoZWFkZXJzO1xyXG59XHJcblxyXG5jb25zdCBJTlRFUk5BTFMkMSA9IFN5bWJvbCgnUmVzcG9uc2UgaW50ZXJuYWxzJyk7XHJcblxyXG4vLyBmaXggYW4gaXNzdWUgd2hlcmUgXCJTVEFUVVNfQ09ERVNcIiBhcmVuJ3QgYSBuYW1lZCBleHBvcnQgZm9yIG5vZGUgPDEwXHJcbmNvbnN0IFNUQVRVU19DT0RFUyA9IGh0dHAuU1RBVFVTX0NPREVTO1xyXG5cclxuLyoqXHJcbiAqIFJlc3BvbnNlIGNsYXNzXHJcbiAqXHJcbiAqIEBwYXJhbSAgIFN0cmVhbSAgYm9keSAgUmVhZGFibGUgc3RyZWFtXHJcbiAqIEBwYXJhbSAgIE9iamVjdCAgb3B0cyAgUmVzcG9uc2Ugb3B0aW9uc1xyXG4gKiBAcmV0dXJuICBWb2lkXHJcbiAqL1xyXG5jbGFzcyBSZXNwb25zZSB7XHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHRsZXQgYm9keSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcclxuXHRcdGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcclxuXHJcblx0XHRCb2R5LmNhbGwodGhpcywgYm9keSwgb3B0cyk7XHJcblxyXG5cdFx0Y29uc3Qgc3RhdHVzID0gb3B0cy5zdGF0dXMgfHwgMjAwO1xyXG5cdFx0Y29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdHMuaGVhZGVycyk7XHJcblxyXG5cdFx0aWYgKGJvZHkgIT0gbnVsbCAmJiAhaGVhZGVycy5oYXMoJ0NvbnRlbnQtVHlwZScpKSB7XHJcblx0XHRcdGNvbnN0IGNvbnRlbnRUeXBlID0gZXh0cmFjdENvbnRlbnRUeXBlKGJvZHkpO1xyXG5cdFx0XHRpZiAoY29udGVudFR5cGUpIHtcclxuXHRcdFx0XHRoZWFkZXJzLmFwcGVuZCgnQ29udGVudC1UeXBlJywgY29udGVudFR5cGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpc1tJTlRFUk5BTFMkMV0gPSB7XHJcblx0XHRcdHVybDogb3B0cy51cmwsXHJcblx0XHRcdHN0YXR1cyxcclxuXHRcdFx0c3RhdHVzVGV4dDogb3B0cy5zdGF0dXNUZXh0IHx8IFNUQVRVU19DT0RFU1tzdGF0dXNdLFxyXG5cdFx0XHRoZWFkZXJzLFxyXG5cdFx0XHRjb3VudGVyOiBvcHRzLmNvdW50ZXJcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHRnZXQgdXJsKCkge1xyXG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDFdLnVybCB8fCAnJztcclxuXHR9XHJcblxyXG5cdGdldCBzdGF0dXMoKSB7XHJcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0uc3RhdHVzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcbiAgKiBDb252ZW5pZW5jZSBwcm9wZXJ0eSByZXByZXNlbnRpbmcgaWYgdGhlIHJlcXVlc3QgZW5kZWQgbm9ybWFsbHlcclxuICAqL1xyXG5cdGdldCBvaygpIHtcclxuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMUyQxXS5zdGF0dXMgPj0gMjAwICYmIHRoaXNbSU5URVJOQUxTJDFdLnN0YXR1cyA8IDMwMDtcclxuXHR9XHJcblxyXG5cdGdldCByZWRpcmVjdGVkKCkge1xyXG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDFdLmNvdW50ZXIgPiAwO1xyXG5cdH1cclxuXHJcblx0Z2V0IHN0YXR1c1RleHQoKSB7XHJcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0uc3RhdHVzVGV4dDtcclxuXHR9XHJcblxyXG5cdGdldCBoZWFkZXJzKCkge1xyXG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDFdLmhlYWRlcnM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuICAqIENsb25lIHRoaXMgcmVzcG9uc2VcclxuICAqXHJcbiAgKiBAcmV0dXJuICBSZXNwb25zZVxyXG4gICovXHJcblx0Y2xvbmUoKSB7XHJcblx0XHRyZXR1cm4gbmV3IFJlc3BvbnNlKGNsb25lKHRoaXMpLCB7XHJcblx0XHRcdHVybDogdGhpcy51cmwsXHJcblx0XHRcdHN0YXR1czogdGhpcy5zdGF0dXMsXHJcblx0XHRcdHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcclxuXHRcdFx0aGVhZGVyczogdGhpcy5oZWFkZXJzLFxyXG5cdFx0XHRvazogdGhpcy5vayxcclxuXHRcdFx0cmVkaXJlY3RlZDogdGhpcy5yZWRpcmVjdGVkXHJcblx0XHR9KTtcclxuXHR9XHJcbn1cclxuXHJcbkJvZHkubWl4SW4oUmVzcG9uc2UucHJvdG90eXBlKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlc3BvbnNlLnByb3RvdHlwZSwge1xyXG5cdHVybDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcblx0c3RhdHVzOiB7IGVudW1lcmFibGU6IHRydWUgfSxcclxuXHRvazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcblx0cmVkaXJlY3RlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcblx0c3RhdHVzVGV4dDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcblx0aGVhZGVyczogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcblx0Y2xvbmU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XHJcbn0pO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlc3BvbnNlLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XHJcblx0dmFsdWU6ICdSZXNwb25zZScsXHJcblx0d3JpdGFibGU6IGZhbHNlLFxyXG5cdGVudW1lcmFibGU6IGZhbHNlLFxyXG5cdGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG59KTtcclxuXHJcbmNvbnN0IElOVEVSTkFMUyQyID0gU3ltYm9sKCdSZXF1ZXN0IGludGVybmFscycpO1xyXG5cclxuLy8gZml4IGFuIGlzc3VlIHdoZXJlIFwiZm9ybWF0XCIsIFwicGFyc2VcIiBhcmVuJ3QgYSBuYW1lZCBleHBvcnQgZm9yIG5vZGUgPDEwXHJcbmNvbnN0IHBhcnNlX3VybCA9IFVybC5wYXJzZTtcclxuY29uc3QgZm9ybWF0X3VybCA9IFVybC5mb3JtYXQ7XHJcblxyXG5jb25zdCBzdHJlYW1EZXN0cnVjdGlvblN1cHBvcnRlZCA9ICdkZXN0cm95JyBpbiBTdHJlYW0uUmVhZGFibGUucHJvdG90eXBlO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgUmVxdWVzdC5cclxuICpcclxuICogQHBhcmFtICAgTWl4ZWQgICBpbnB1dFxyXG4gKiBAcmV0dXJuICBCb29sZWFuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1JlcXVlc3QoaW5wdXQpIHtcclxuXHRyZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgaW5wdXRbSU5URVJOQUxTJDJdID09PSAnb2JqZWN0JztcclxufVxyXG5cclxuZnVuY3Rpb24gaXNBYm9ydFNpZ25hbChzaWduYWwpIHtcclxuXHRjb25zdCBwcm90byA9IHNpZ25hbCAmJiB0eXBlb2Ygc2lnbmFsID09PSAnb2JqZWN0JyAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc2lnbmFsKTtcclxuXHRyZXR1cm4gISEocHJvdG8gJiYgcHJvdG8uY29uc3RydWN0b3IubmFtZSA9PT0gJ0Fib3J0U2lnbmFsJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXF1ZXN0IGNsYXNzXHJcbiAqXHJcbiAqIEBwYXJhbSAgIE1peGVkICAgaW5wdXQgIFVybCBvciBSZXF1ZXN0IGluc3RhbmNlXHJcbiAqIEBwYXJhbSAgIE9iamVjdCAgaW5pdCAgIEN1c3RvbSBvcHRpb25zXHJcbiAqIEByZXR1cm4gIFZvaWRcclxuICovXHJcbmNsYXNzIFJlcXVlc3Qge1xyXG5cdGNvbnN0cnVjdG9yKGlucHV0KSB7XHJcblx0XHRsZXQgaW5pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XHJcblxyXG5cdFx0bGV0IHBhcnNlZFVSTDtcclxuXHJcblx0XHQvLyBub3JtYWxpemUgaW5wdXRcclxuXHRcdGlmICghaXNSZXF1ZXN0KGlucHV0KSkge1xyXG5cdFx0XHRpZiAoaW5wdXQgJiYgaW5wdXQuaHJlZikge1xyXG5cdFx0XHRcdC8vIGluIG9yZGVyIHRvIHN1cHBvcnQgTm9kZS5qcycgVXJsIG9iamVjdHM7IHRob3VnaCBXSEFUV0cncyBVUkwgb2JqZWN0c1xyXG5cdFx0XHRcdC8vIHdpbGwgZmFsbCBpbnRvIHRoaXMgYnJhbmNoIGFsc28gKHNpbmNlIHRoZWlyIGB0b1N0cmluZygpYCB3aWxsIHJldHVyblxyXG5cdFx0XHRcdC8vIGBocmVmYCBwcm9wZXJ0eSBhbnl3YXkpXHJcblx0XHRcdFx0cGFyc2VkVVJMID0gcGFyc2VfdXJsKGlucHV0LmhyZWYpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIGNvZXJjZSBpbnB1dCB0byBhIHN0cmluZyBiZWZvcmUgYXR0ZW1wdGluZyB0byBwYXJzZVxyXG5cdFx0XHRcdHBhcnNlZFVSTCA9IHBhcnNlX3VybChgJHtpbnB1dH1gKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpbnB1dCA9IHt9O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cGFyc2VkVVJMID0gcGFyc2VfdXJsKGlucHV0LnVybCk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IG1ldGhvZCA9IGluaXQubWV0aG9kIHx8IGlucHV0Lm1ldGhvZCB8fCAnR0VUJztcclxuXHRcdG1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xyXG5cclxuXHRcdGlmICgoaW5pdC5ib2R5ICE9IG51bGwgfHwgaXNSZXF1ZXN0KGlucHV0KSAmJiBpbnB1dC5ib2R5ICE9PSBudWxsKSAmJiAobWV0aG9kID09PSAnR0VUJyB8fCBtZXRob2QgPT09ICdIRUFEJykpIHtcclxuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignUmVxdWVzdCB3aXRoIEdFVC9IRUFEIG1ldGhvZCBjYW5ub3QgaGF2ZSBib2R5Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGlucHV0Qm9keSA9IGluaXQuYm9keSAhPSBudWxsID8gaW5pdC5ib2R5IDogaXNSZXF1ZXN0KGlucHV0KSAmJiBpbnB1dC5ib2R5ICE9PSBudWxsID8gY2xvbmUoaW5wdXQpIDogbnVsbDtcclxuXHJcblx0XHRCb2R5LmNhbGwodGhpcywgaW5wdXRCb2R5LCB7XHJcblx0XHRcdHRpbWVvdXQ6IGluaXQudGltZW91dCB8fCBpbnB1dC50aW1lb3V0IHx8IDAsXHJcblx0XHRcdHNpemU6IGluaXQuc2l6ZSB8fCBpbnB1dC5zaXplIHx8IDBcclxuXHRcdH0pO1xyXG5cclxuXHRcdGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbml0LmhlYWRlcnMgfHwgaW5wdXQuaGVhZGVycyB8fCB7fSk7XHJcblxyXG5cdFx0aWYgKGlucHV0Qm9keSAhPSBudWxsICYmICFoZWFkZXJzLmhhcygnQ29udGVudC1UeXBlJykpIHtcclxuXHRcdFx0Y29uc3QgY29udGVudFR5cGUgPSBleHRyYWN0Q29udGVudFR5cGUoaW5wdXRCb2R5KTtcclxuXHRcdFx0aWYgKGNvbnRlbnRUeXBlKSB7XHJcblx0XHRcdFx0aGVhZGVycy5hcHBlbmQoJ0NvbnRlbnQtVHlwZScsIGNvbnRlbnRUeXBlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBzaWduYWwgPSBpc1JlcXVlc3QoaW5wdXQpID8gaW5wdXQuc2lnbmFsIDogbnVsbDtcclxuXHRcdGlmICgnc2lnbmFsJyBpbiBpbml0KSBzaWduYWwgPSBpbml0LnNpZ25hbDtcclxuXHJcblx0XHRpZiAoc2lnbmFsICE9IG51bGwgJiYgIWlzQWJvcnRTaWduYWwoc2lnbmFsKSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBzaWduYWwgdG8gYmUgYW4gaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXNbSU5URVJOQUxTJDJdID0ge1xyXG5cdFx0XHRtZXRob2QsXHJcblx0XHRcdHJlZGlyZWN0OiBpbml0LnJlZGlyZWN0IHx8IGlucHV0LnJlZGlyZWN0IHx8ICdmb2xsb3cnLFxyXG5cdFx0XHRoZWFkZXJzLFxyXG5cdFx0XHRwYXJzZWRVUkwsXHJcblx0XHRcdHNpZ25hbFxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBub2RlLWZldGNoLW9ubHkgb3B0aW9uc1xyXG5cdFx0dGhpcy5mb2xsb3cgPSBpbml0LmZvbGxvdyAhPT0gdW5kZWZpbmVkID8gaW5pdC5mb2xsb3cgOiBpbnB1dC5mb2xsb3cgIT09IHVuZGVmaW5lZCA/IGlucHV0LmZvbGxvdyA6IDIwO1xyXG5cdFx0dGhpcy5jb21wcmVzcyA9IGluaXQuY29tcHJlc3MgIT09IHVuZGVmaW5lZCA/IGluaXQuY29tcHJlc3MgOiBpbnB1dC5jb21wcmVzcyAhPT0gdW5kZWZpbmVkID8gaW5wdXQuY29tcHJlc3MgOiB0cnVlO1xyXG5cdFx0dGhpcy5jb3VudGVyID0gaW5pdC5jb3VudGVyIHx8IGlucHV0LmNvdW50ZXIgfHwgMDtcclxuXHRcdHRoaXMuYWdlbnQgPSBpbml0LmFnZW50IHx8IGlucHV0LmFnZW50O1xyXG5cdH1cclxuXHJcblx0Z2V0IG1ldGhvZCgpIHtcclxuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMUyQyXS5tZXRob2Q7XHJcblx0fVxyXG5cclxuXHRnZXQgdXJsKCkge1xyXG5cdFx0cmV0dXJuIGZvcm1hdF91cmwodGhpc1tJTlRFUk5BTFMkMl0ucGFyc2VkVVJMKTtcclxuXHR9XHJcblxyXG5cdGdldCBoZWFkZXJzKCkge1xyXG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDJdLmhlYWRlcnM7XHJcblx0fVxyXG5cclxuXHRnZXQgcmVkaXJlY3QoKSB7XHJcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMl0ucmVkaXJlY3Q7XHJcblx0fVxyXG5cclxuXHRnZXQgc2lnbmFsKCkge1xyXG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDJdLnNpZ25hbDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG4gICogQ2xvbmUgdGhpcyByZXF1ZXN0XHJcbiAgKlxyXG4gICogQHJldHVybiAgUmVxdWVzdFxyXG4gICovXHJcblx0Y2xvbmUoKSB7XHJcblx0XHRyZXR1cm4gbmV3IFJlcXVlc3QodGhpcyk7XHJcblx0fVxyXG59XHJcblxyXG5Cb2R5Lm1peEluKFJlcXVlc3QucHJvdG90eXBlKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXF1ZXN0LnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XHJcblx0dmFsdWU6ICdSZXF1ZXN0JyxcclxuXHR3cml0YWJsZTogZmFsc2UsXHJcblx0ZW51bWVyYWJsZTogZmFsc2UsXHJcblx0Y29uZmlndXJhYmxlOiB0cnVlXHJcbn0pO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVxdWVzdC5wcm90b3R5cGUsIHtcclxuXHRtZXRob2Q6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxyXG5cdHVybDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcblx0aGVhZGVyczogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcblx0cmVkaXJlY3Q6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxyXG5cdGNsb25lOiB7IGVudW1lcmFibGU6IHRydWUgfSxcclxuXHRzaWduYWw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYSBSZXF1ZXN0IHRvIE5vZGUuanMgaHR0cCByZXF1ZXN0IG9wdGlvbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSAgIFJlcXVlc3QgIEEgUmVxdWVzdCBpbnN0YW5jZVxyXG4gKiBAcmV0dXJuICBPYmplY3QgICBUaGUgb3B0aW9ucyBvYmplY3QgdG8gYmUgcGFzc2VkIHRvIGh0dHAucmVxdWVzdFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Tm9kZVJlcXVlc3RPcHRpb25zKHJlcXVlc3QpIHtcclxuXHRjb25zdCBwYXJzZWRVUkwgPSByZXF1ZXN0W0lOVEVSTkFMUyQyXS5wYXJzZWRVUkw7XHJcblx0Y29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlcXVlc3RbSU5URVJOQUxTJDJdLmhlYWRlcnMpO1xyXG5cclxuXHQvLyBmZXRjaCBzdGVwIDEuM1xyXG5cdGlmICghaGVhZGVycy5oYXMoJ0FjY2VwdCcpKSB7XHJcblx0XHRoZWFkZXJzLnNldCgnQWNjZXB0JywgJyovKicpO1xyXG5cdH1cclxuXHJcblx0Ly8gQmFzaWMgZmV0Y2hcclxuXHRpZiAoIXBhcnNlZFVSTC5wcm90b2NvbCB8fCAhcGFyc2VkVVJMLmhvc3RuYW1lKSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPbmx5IGFic29sdXRlIFVSTHMgYXJlIHN1cHBvcnRlZCcpO1xyXG5cdH1cclxuXHJcblx0aWYgKCEvXmh0dHBzPzokLy50ZXN0KHBhcnNlZFVSTC5wcm90b2NvbCkpIHtcclxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09ubHkgSFRUUChTKSBwcm90b2NvbHMgYXJlIHN1cHBvcnRlZCcpO1xyXG5cdH1cclxuXHJcblx0aWYgKHJlcXVlc3Quc2lnbmFsICYmIHJlcXVlc3QuYm9keSBpbnN0YW5jZW9mIFN0cmVhbS5SZWFkYWJsZSAmJiAhc3RyZWFtRGVzdHJ1Y3Rpb25TdXBwb3J0ZWQpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcignQ2FuY2VsbGF0aW9uIG9mIHN0cmVhbWVkIHJlcXVlc3RzIHdpdGggQWJvcnRTaWduYWwgaXMgbm90IHN1cHBvcnRlZCBpbiBub2RlIDwgOCcpO1xyXG5cdH1cclxuXHJcblx0Ly8gSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoIHN0ZXBzIDIuNC0yLjdcclxuXHRsZXQgY29udGVudExlbmd0aFZhbHVlID0gbnVsbDtcclxuXHRpZiAocmVxdWVzdC5ib2R5ID09IG51bGwgJiYgL14oUE9TVHxQVVQpJC9pLnRlc3QocmVxdWVzdC5tZXRob2QpKSB7XHJcblx0XHRjb250ZW50TGVuZ3RoVmFsdWUgPSAnMCc7XHJcblx0fVxyXG5cdGlmIChyZXF1ZXN0LmJvZHkgIT0gbnVsbCkge1xyXG5cdFx0Y29uc3QgdG90YWxCeXRlcyA9IGdldFRvdGFsQnl0ZXMocmVxdWVzdCk7XHJcblx0XHRpZiAodHlwZW9mIHRvdGFsQnl0ZXMgPT09ICdudW1iZXInKSB7XHJcblx0XHRcdGNvbnRlbnRMZW5ndGhWYWx1ZSA9IFN0cmluZyh0b3RhbEJ5dGVzKTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGNvbnRlbnRMZW5ndGhWYWx1ZSkge1xyXG5cdFx0aGVhZGVycy5zZXQoJ0NvbnRlbnQtTGVuZ3RoJywgY29udGVudExlbmd0aFZhbHVlKTtcclxuXHR9XHJcblxyXG5cdC8vIEhUVFAtbmV0d29yay1vci1jYWNoZSBmZXRjaCBzdGVwIDIuMTFcclxuXHRpZiAoIWhlYWRlcnMuaGFzKCdVc2VyLUFnZW50JykpIHtcclxuXHRcdGhlYWRlcnMuc2V0KCdVc2VyLUFnZW50JywgJ25vZGUtZmV0Y2gvMS4wICgraHR0cHM6Ly9naXRodWIuY29tL2JpdGlubi9ub2RlLWZldGNoKScpO1xyXG5cdH1cclxuXHJcblx0Ly8gSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoIHN0ZXAgMi4xNVxyXG5cdGlmIChyZXF1ZXN0LmNvbXByZXNzICYmICFoZWFkZXJzLmhhcygnQWNjZXB0LUVuY29kaW5nJykpIHtcclxuXHRcdGhlYWRlcnMuc2V0KCdBY2NlcHQtRW5jb2RpbmcnLCAnZ3ppcCxkZWZsYXRlJyk7XHJcblx0fVxyXG5cclxuXHRsZXQgYWdlbnQgPSByZXF1ZXN0LmFnZW50O1xyXG5cdGlmICh0eXBlb2YgYWdlbnQgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdGFnZW50ID0gYWdlbnQocGFyc2VkVVJMKTtcclxuXHR9XHJcblxyXG5cdGlmICghaGVhZGVycy5oYXMoJ0Nvbm5lY3Rpb24nKSAmJiAhYWdlbnQpIHtcclxuXHRcdGhlYWRlcnMuc2V0KCdDb25uZWN0aW9uJywgJ2Nsb3NlJyk7XHJcblx0fVxyXG5cclxuXHQvLyBIVFRQLW5ldHdvcmsgZmV0Y2ggc3RlcCA0LjJcclxuXHQvLyBjaHVua2VkIGVuY29kaW5nIGlzIGhhbmRsZWQgYnkgTm9kZS5qc1xyXG5cclxuXHRyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkVVJMLCB7XHJcblx0XHRtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxyXG5cdFx0aGVhZGVyczogZXhwb3J0Tm9kZUNvbXBhdGlibGVIZWFkZXJzKGhlYWRlcnMpLFxyXG5cdFx0YWdlbnRcclxuXHR9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGFib3J0LWVycm9yLmpzXHJcbiAqXHJcbiAqIEFib3J0RXJyb3IgaW50ZXJmYWNlIGZvciBjYW5jZWxsZWQgcmVxdWVzdHNcclxuICovXHJcblxyXG4vKipcclxuICogQ3JlYXRlIEFib3J0RXJyb3IgaW5zdGFuY2VcclxuICpcclxuICogQHBhcmFtICAgU3RyaW5nICAgICAgbWVzc2FnZSAgICAgIEVycm9yIG1lc3NhZ2UgZm9yIGh1bWFuXHJcbiAqIEByZXR1cm4gIEFib3J0RXJyb3JcclxuICovXHJcbmZ1bmN0aW9uIEFib3J0RXJyb3IobWVzc2FnZSkge1xyXG4gIEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XHJcblxyXG4gIHRoaXMudHlwZSA9ICdhYm9ydGVkJztcclxuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG5cclxuICAvLyBoaWRlIGN1c3RvbSBlcnJvciBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIGZyb20gZW5kLXVzZXJzXHJcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XHJcbn1cclxuXHJcbkFib3J0RXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xyXG5BYm9ydEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFib3J0RXJyb3I7XHJcbkFib3J0RXJyb3IucHJvdG90eXBlLm5hbWUgPSAnQWJvcnRFcnJvcic7XHJcblxyXG4vLyBmaXggYW4gaXNzdWUgd2hlcmUgXCJQYXNzVGhyb3VnaFwiLCBcInJlc29sdmVcIiBhcmVuJ3QgYSBuYW1lZCBleHBvcnQgZm9yIG5vZGUgPDEwXHJcbmNvbnN0IFBhc3NUaHJvdWdoJDEgPSBTdHJlYW0uUGFzc1Rocm91Z2g7XHJcbmNvbnN0IHJlc29sdmVfdXJsID0gVXJsLnJlc29sdmU7XHJcblxyXG4vKipcclxuICogRmV0Y2ggZnVuY3Rpb25cclxuICpcclxuICogQHBhcmFtICAgTWl4ZWQgICAgdXJsICAgQWJzb2x1dGUgdXJsIG9yIFJlcXVlc3QgaW5zdGFuY2VcclxuICogQHBhcmFtICAgT2JqZWN0ICAgb3B0cyAgRmV0Y2ggb3B0aW9uc1xyXG4gKiBAcmV0dXJuICBQcm9taXNlXHJcbiAqL1xyXG5mdW5jdGlvbiBmZXRjaCh1cmwsIG9wdHMpIHtcclxuXHJcblx0Ly8gYWxsb3cgY3VzdG9tIHByb21pc2VcclxuXHRpZiAoIWZldGNoLlByb21pc2UpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcignbmF0aXZlIHByb21pc2UgbWlzc2luZywgc2V0IGZldGNoLlByb21pc2UgdG8geW91ciBmYXZvcml0ZSBhbHRlcm5hdGl2ZScpO1xyXG5cdH1cclxuXHJcblx0Qm9keS5Qcm9taXNlID0gZmV0Y2guUHJvbWlzZTtcclxuXHJcblx0Ly8gd3JhcCBodHRwLnJlcXVlc3QgaW50byBmZXRjaFxyXG5cdHJldHVybiBuZXcgZmV0Y2guUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcblx0XHQvLyBidWlsZCByZXF1ZXN0IG9iamVjdFxyXG5cdFx0Y29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCwgb3B0cyk7XHJcblx0XHRjb25zdCBvcHRpb25zID0gZ2V0Tm9kZVJlcXVlc3RPcHRpb25zKHJlcXVlc3QpO1xyXG5cclxuXHRcdGNvbnN0IHNlbmQgPSAob3B0aW9ucy5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyBodHRwcyA6IGh0dHApLnJlcXVlc3Q7XHJcblx0XHRjb25zdCBzaWduYWwgPSByZXF1ZXN0LnNpZ25hbDtcclxuXHJcblx0XHRsZXQgcmVzcG9uc2UgPSBudWxsO1xyXG5cclxuXHRcdGNvbnN0IGFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XHJcblx0XHRcdGxldCBlcnJvciA9IG5ldyBBYm9ydEVycm9yKCdUaGUgdXNlciBhYm9ydGVkIGEgcmVxdWVzdC4nKTtcclxuXHRcdFx0cmVqZWN0KGVycm9yKTtcclxuXHRcdFx0aWYgKHJlcXVlc3QuYm9keSAmJiByZXF1ZXN0LmJvZHkgaW5zdGFuY2VvZiBTdHJlYW0uUmVhZGFibGUpIHtcclxuXHRcdFx0XHRyZXF1ZXN0LmJvZHkuZGVzdHJveShlcnJvcik7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCFyZXNwb25zZSB8fCAhcmVzcG9uc2UuYm9keSkgcmV0dXJuO1xyXG5cdFx0XHRyZXNwb25zZS5ib2R5LmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkKSB7XHJcblx0XHRcdGFib3J0KCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBhYm9ydEFuZEZpbmFsaXplID0gZnVuY3Rpb24gYWJvcnRBbmRGaW5hbGl6ZSgpIHtcclxuXHRcdFx0YWJvcnQoKTtcclxuXHRcdFx0ZmluYWxpemUoKTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gc2VuZCByZXF1ZXN0XHJcblx0XHRjb25zdCByZXEgPSBzZW5kKG9wdGlvbnMpO1xyXG5cdFx0bGV0IHJlcVRpbWVvdXQ7XHJcblxyXG5cdFx0aWYgKHNpZ25hbCkge1xyXG5cdFx0XHRzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEFuZEZpbmFsaXplKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBmaW5hbGl6ZSgpIHtcclxuXHRcdFx0cmVxLmFib3J0KCk7XHJcblx0XHRcdGlmIChzaWduYWwpIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QW5kRmluYWxpemUpO1xyXG5cdFx0XHRjbGVhclRpbWVvdXQocmVxVGltZW91dCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHJlcXVlc3QudGltZW91dCkge1xyXG5cdFx0XHRyZXEub25jZSgnc29ja2V0JywgZnVuY3Rpb24gKHNvY2tldCkge1xyXG5cdFx0XHRcdHJlcVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgbmV0d29yayB0aW1lb3V0IGF0OiAke3JlcXVlc3QudXJsfWAsICdyZXF1ZXN0LXRpbWVvdXQnKSk7XHJcblx0XHRcdFx0XHRmaW5hbGl6ZSgpO1xyXG5cdFx0XHRcdH0sIHJlcXVlc3QudGltZW91dCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XHJcblx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgcmVxdWVzdCB0byAke3JlcXVlc3QudXJsfSBmYWlsZWQsIHJlYXNvbjogJHtlcnIubWVzc2FnZX1gLCAnc3lzdGVtJywgZXJyKSk7XHJcblx0XHRcdGZpbmFsaXplKCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXEub24oJ3Jlc3BvbnNlJywgZnVuY3Rpb24gKHJlcykge1xyXG5cdFx0XHRjbGVhclRpbWVvdXQocmVxVGltZW91dCk7XHJcblxyXG5cdFx0XHRjb25zdCBoZWFkZXJzID0gY3JlYXRlSGVhZGVyc0xlbmllbnQocmVzLmhlYWRlcnMpO1xyXG5cclxuXHRcdFx0Ly8gSFRUUCBmZXRjaCBzdGVwIDVcclxuXHRcdFx0aWYgKGZldGNoLmlzUmVkaXJlY3QocmVzLnN0YXR1c0NvZGUpKSB7XHJcblx0XHRcdFx0Ly8gSFRUUCBmZXRjaCBzdGVwIDUuMlxyXG5cdFx0XHRcdGNvbnN0IGxvY2F0aW9uID0gaGVhZGVycy5nZXQoJ0xvY2F0aW9uJyk7XHJcblxyXG5cdFx0XHRcdC8vIEhUVFAgZmV0Y2ggc3RlcCA1LjNcclxuXHRcdFx0XHRjb25zdCBsb2NhdGlvblVSTCA9IGxvY2F0aW9uID09PSBudWxsID8gbnVsbCA6IHJlc29sdmVfdXJsKHJlcXVlc3QudXJsLCBsb2NhdGlvbik7XHJcblxyXG5cdFx0XHRcdC8vIEhUVFAgZmV0Y2ggc3RlcCA1LjVcclxuXHRcdFx0XHRzd2l0Y2ggKHJlcXVlc3QucmVkaXJlY3QpIHtcclxuXHRcdFx0XHRcdGNhc2UgJ2Vycm9yJzpcclxuXHRcdFx0XHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKGByZWRpcmVjdCBtb2RlIGlzIHNldCB0byBlcnJvcjogJHtyZXF1ZXN0LnVybH1gLCAnbm8tcmVkaXJlY3QnKSk7XHJcblx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdGNhc2UgJ21hbnVhbCc6XHJcblx0XHRcdFx0XHRcdC8vIG5vZGUtZmV0Y2gtc3BlY2lmaWMgc3RlcDogbWFrZSBtYW51YWwgcmVkaXJlY3QgYSBiaXQgZWFzaWVyIHRvIHVzZSBieSBzZXR0aW5nIHRoZSBMb2NhdGlvbiBoZWFkZXIgdmFsdWUgdG8gdGhlIHJlc29sdmVkIFVSTC5cclxuXHRcdFx0XHRcdFx0aWYgKGxvY2F0aW9uVVJMICE9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gaGFuZGxlIGNvcnJ1cHRlZCBoZWFkZXJcclxuXHRcdFx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHRcdFx0aGVhZGVycy5zZXQoJ0xvY2F0aW9uJywgbG9jYXRpb25VUkwpO1xyXG5cdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gaXN0YW5idWwgaWdub3JlIG5leHQ6IG5vZGVqcyBzZXJ2ZXIgcHJldmVudCBpbnZhbGlkIHJlc3BvbnNlIGhlYWRlcnMsIHdlIGNhbid0IHRlc3QgdGhpcyB0aHJvdWdoIG5vcm1hbCByZXF1ZXN0XHJcblx0XHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdmb2xsb3cnOlxyXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgMlxyXG5cdFx0XHRcdFx0XHRpZiAobG9jYXRpb25VUkwgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDVcclxuXHRcdFx0XHRcdFx0aWYgKHJlcXVlc3QuY291bnRlciA+PSByZXF1ZXN0LmZvbGxvdykge1xyXG5cdFx0XHRcdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgbWF4aW11bSByZWRpcmVjdCByZWFjaGVkIGF0OiAke3JlcXVlc3QudXJsfWAsICdtYXgtcmVkaXJlY3QnKSk7XHJcblx0XHRcdFx0XHRcdFx0ZmluYWxpemUoKTtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCA2IChjb3VudGVyIGluY3JlbWVudClcclxuXHRcdFx0XHRcdFx0Ly8gQ3JlYXRlIGEgbmV3IFJlcXVlc3Qgb2JqZWN0LlxyXG5cdFx0XHRcdFx0XHRjb25zdCByZXF1ZXN0T3B0cyA9IHtcclxuXHRcdFx0XHRcdFx0XHRoZWFkZXJzOiBuZXcgSGVhZGVycyhyZXF1ZXN0LmhlYWRlcnMpLFxyXG5cdFx0XHRcdFx0XHRcdGZvbGxvdzogcmVxdWVzdC5mb2xsb3csXHJcblx0XHRcdFx0XHRcdFx0Y291bnRlcjogcmVxdWVzdC5jb3VudGVyICsgMSxcclxuXHRcdFx0XHRcdFx0XHRhZ2VudDogcmVxdWVzdC5hZ2VudCxcclxuXHRcdFx0XHRcdFx0XHRjb21wcmVzczogcmVxdWVzdC5jb21wcmVzcyxcclxuXHRcdFx0XHRcdFx0XHRtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxyXG5cdFx0XHRcdFx0XHRcdGJvZHk6IHJlcXVlc3QuYm9keSxcclxuXHRcdFx0XHRcdFx0XHRzaWduYWw6IHJlcXVlc3Quc2lnbmFsLFxyXG5cdFx0XHRcdFx0XHRcdHRpbWVvdXQ6IHJlcXVlc3QudGltZW91dFxyXG5cdFx0XHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDlcclxuXHRcdFx0XHRcdFx0aWYgKHJlcy5zdGF0dXNDb2RlICE9PSAzMDMgJiYgcmVxdWVzdC5ib2R5ICYmIGdldFRvdGFsQnl0ZXMocmVxdWVzdCkgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoJ0Nhbm5vdCBmb2xsb3cgcmVkaXJlY3Qgd2l0aCBib2R5IGJlaW5nIGEgcmVhZGFibGUgc3RyZWFtJywgJ3Vuc3VwcG9ydGVkLXJlZGlyZWN0JykpO1xyXG5cdFx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgMTFcclxuXHRcdFx0XHRcdFx0aWYgKHJlcy5zdGF0dXNDb2RlID09PSAzMDMgfHwgKHJlcy5zdGF0dXNDb2RlID09PSAzMDEgfHwgcmVzLnN0YXR1c0NvZGUgPT09IDMwMikgJiYgcmVxdWVzdC5tZXRob2QgPT09ICdQT1NUJykge1xyXG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RPcHRzLm1ldGhvZCA9ICdHRVQnO1xyXG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RPcHRzLmJvZHkgPSB1bmRlZmluZWQ7XHJcblx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdHMuaGVhZGVycy5kZWxldGUoJ2NvbnRlbnQtbGVuZ3RoJyk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCAxNVxyXG5cdFx0XHRcdFx0XHRyZXNvbHZlKGZldGNoKG5ldyBSZXF1ZXN0KGxvY2F0aW9uVVJMLCByZXF1ZXN0T3B0cykpKTtcclxuXHRcdFx0XHRcdFx0ZmluYWxpemUoKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gcHJlcGFyZSByZXNwb25zZVxyXG5cdFx0XHRyZXMub25jZSgnZW5kJywgZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdGlmIChzaWduYWwpIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QW5kRmluYWxpemUpO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0bGV0IGJvZHkgPSByZXMucGlwZShuZXcgUGFzc1Rocm91Z2gkMSgpKTtcclxuXHJcblx0XHRcdGNvbnN0IHJlc3BvbnNlX29wdGlvbnMgPSB7XHJcblx0XHRcdFx0dXJsOiByZXF1ZXN0LnVybCxcclxuXHRcdFx0XHRzdGF0dXM6IHJlcy5zdGF0dXNDb2RlLFxyXG5cdFx0XHRcdHN0YXR1c1RleHQ6IHJlcy5zdGF0dXNNZXNzYWdlLFxyXG5cdFx0XHRcdGhlYWRlcnM6IGhlYWRlcnMsXHJcblx0XHRcdFx0c2l6ZTogcmVxdWVzdC5zaXplLFxyXG5cdFx0XHRcdHRpbWVvdXQ6IHJlcXVlc3QudGltZW91dCxcclxuXHRcdFx0XHRjb3VudGVyOiByZXF1ZXN0LmNvdW50ZXJcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdC8vIEhUVFAtbmV0d29yayBmZXRjaCBzdGVwIDEyLjEuMS4zXHJcblx0XHRcdGNvbnN0IGNvZGluZ3MgPSBoZWFkZXJzLmdldCgnQ29udGVudC1FbmNvZGluZycpO1xyXG5cclxuXHRcdFx0Ly8gSFRUUC1uZXR3b3JrIGZldGNoIHN0ZXAgMTIuMS4xLjQ6IGhhbmRsZSBjb250ZW50IGNvZGluZ3NcclxuXHJcblx0XHRcdC8vIGluIGZvbGxvd2luZyBzY2VuYXJpb3Mgd2UgaWdub3JlIGNvbXByZXNzaW9uIHN1cHBvcnRcclxuXHRcdFx0Ly8gMS4gY29tcHJlc3Npb24gc3VwcG9ydCBpcyBkaXNhYmxlZFxyXG5cdFx0XHQvLyAyLiBIRUFEIHJlcXVlc3RcclxuXHRcdFx0Ly8gMy4gbm8gQ29udGVudC1FbmNvZGluZyBoZWFkZXJcclxuXHRcdFx0Ly8gNC4gbm8gY29udGVudCByZXNwb25zZSAoMjA0KVxyXG5cdFx0XHQvLyA1LiBjb250ZW50IG5vdCBtb2RpZmllZCByZXNwb25zZSAoMzA0KVxyXG5cdFx0XHRpZiAoIXJlcXVlc3QuY29tcHJlc3MgfHwgcmVxdWVzdC5tZXRob2QgPT09ICdIRUFEJyB8fCBjb2RpbmdzID09PSBudWxsIHx8IHJlcy5zdGF0dXNDb2RlID09PSAyMDQgfHwgcmVzLnN0YXR1c0NvZGUgPT09IDMwNCkge1xyXG5cdFx0XHRcdHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlX29wdGlvbnMpO1xyXG5cdFx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gRm9yIE5vZGUgdjYrXHJcblx0XHRcdC8vIEJlIGxlc3Mgc3RyaWN0IHdoZW4gZGVjb2RpbmcgY29tcHJlc3NlZCByZXNwb25zZXMsIHNpbmNlIHNvbWV0aW1lc1xyXG5cdFx0XHQvLyBzZXJ2ZXJzIHNlbmQgc2xpZ2h0bHkgaW52YWxpZCByZXNwb25zZXMgdGhhdCBhcmUgc3RpbGwgYWNjZXB0ZWRcclxuXHRcdFx0Ly8gYnkgY29tbW9uIGJyb3dzZXJzLlxyXG5cdFx0XHQvLyBBbHdheXMgdXNpbmcgWl9TWU5DX0ZMVVNIIGlzIHdoYXQgY1VSTCBkb2VzLlxyXG5cdFx0XHRjb25zdCB6bGliT3B0aW9ucyA9IHtcclxuXHRcdFx0XHRmbHVzaDogemxpYi5aX1NZTkNfRkxVU0gsXHJcblx0XHRcdFx0ZmluaXNoRmx1c2g6IHpsaWIuWl9TWU5DX0ZMVVNIXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHQvLyBmb3IgZ3ppcFxyXG5cdFx0XHRpZiAoY29kaW5ncyA9PSAnZ3ppcCcgfHwgY29kaW5ncyA9PSAneC1nemlwJykge1xyXG5cdFx0XHRcdGJvZHkgPSBib2R5LnBpcGUoemxpYi5jcmVhdGVHdW56aXAoemxpYk9wdGlvbnMpKTtcclxuXHRcdFx0XHRyZXNwb25zZSA9IG5ldyBSZXNwb25zZShib2R5LCByZXNwb25zZV9vcHRpb25zKTtcclxuXHRcdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGZvciBkZWZsYXRlXHJcblx0XHRcdGlmIChjb2RpbmdzID09ICdkZWZsYXRlJyB8fCBjb2RpbmdzID09ICd4LWRlZmxhdGUnKSB7XHJcblx0XHRcdFx0Ly8gaGFuZGxlIHRoZSBpbmZhbW91cyByYXcgZGVmbGF0ZSByZXNwb25zZSBmcm9tIG9sZCBzZXJ2ZXJzXHJcblx0XHRcdFx0Ly8gYSBoYWNrIGZvciBvbGQgSUlTIGFuZCBBcGFjaGUgc2VydmVyc1xyXG5cdFx0XHRcdGNvbnN0IHJhdyA9IHJlcy5waXBlKG5ldyBQYXNzVGhyb3VnaCQxKCkpO1xyXG5cdFx0XHRcdHJhdy5vbmNlKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XHJcblx0XHRcdFx0XHQvLyBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNzUxOTgyOFxyXG5cdFx0XHRcdFx0aWYgKChjaHVua1swXSAmIDB4MEYpID09PSAweDA4KSB7XHJcblx0XHRcdFx0XHRcdGJvZHkgPSBib2R5LnBpcGUoemxpYi5jcmVhdGVJbmZsYXRlKCkpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0Ym9keSA9IGJvZHkucGlwZSh6bGliLmNyZWF0ZUluZmxhdGVSYXcoKSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXNwb25zZSA9IG5ldyBSZXNwb25zZShib2R5LCByZXNwb25zZV9vcHRpb25zKTtcclxuXHRcdFx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZm9yIGJyXHJcblx0XHRcdGlmIChjb2RpbmdzID09ICdicicgJiYgdHlwZW9mIHpsaWIuY3JlYXRlQnJvdGxpRGVjb21wcmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdGJvZHkgPSBib2R5LnBpcGUoemxpYi5jcmVhdGVCcm90bGlEZWNvbXByZXNzKCkpO1xyXG5cdFx0XHRcdHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlX29wdGlvbnMpO1xyXG5cdFx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gb3RoZXJ3aXNlLCB1c2UgcmVzcG9uc2UgYXMtaXNcclxuXHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2Vfb3B0aW9ucyk7XHJcblx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0d3JpdGVUb1N0cmVhbShyZXEsIHJlcXVlc3QpO1xyXG5cdH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZWRpcmVjdCBjb2RlIG1hdGNoaW5nXHJcbiAqXHJcbiAqIEBwYXJhbSAgIE51bWJlciAgIGNvZGUgIFN0YXR1cyBjb2RlXHJcbiAqIEByZXR1cm4gIEJvb2xlYW5cclxuICovXHJcbmZldGNoLmlzUmVkaXJlY3QgPSBmdW5jdGlvbiAoY29kZSkge1xyXG5cdHJldHVybiBjb2RlID09PSAzMDEgfHwgY29kZSA9PT0gMzAyIHx8IGNvZGUgPT09IDMwMyB8fCBjb2RlID09PSAzMDcgfHwgY29kZSA9PT0gMzA4O1xyXG59O1xyXG5cclxuLy8gZXhwb3NlIFByb21pc2VcclxuZmV0Y2guUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZmV0Y2g7XHJcbmV4cG9ydCB7IEhlYWRlcnMsIFJlcXVlc3QsIFJlc3BvbnNlLCBGZXRjaEVycm9yIH07XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/node-fetch/lib/index.mjs\n");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var minimist__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! minimist */ \"./node_modules/minimist/index.js\");\n/* harmony import */ var minimist__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(minimist__WEBPACK_IMPORTED_MODULE_0__);\n\r\nvar argv = minimist__WEBPACK_IMPORTED_MODULE_0___default()(process.argv);\r\nconsole.log(\"Arguments:\");\r\nconsole.log(argv);\r\n__webpack_require__(/*! ./test/main.test */ \"./src/test/main.test.ts\");\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXgudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXgudHM/NzFiZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbWluaW1pc3RGdW5jIGZyb20gXCJtaW5pbWlzdFwiO1xyXG52YXIgYXJndiA9IG1pbmltaXN0RnVuYyhwcm9jZXNzLmFyZ3YpO1xyXG5jb25zb2xlLmxvZyhcIkFyZ3VtZW50czpcIik7XHJcbmNvbnNvbGUubG9nKGFyZ3YpO1xyXG5yZXF1aXJlKCcuL3Rlc3QvbWFpbi50ZXN0Jyk7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.ts\n");

/***/ }),

/***/ "./src/lib/replacer.ts":
/*!*****************************!*\
  !*** ./src/lib/replacer.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar split = \"￥\";\r\nexports.setSplit = setSplit;\r\nexports.replaceContent = replaceContent;\r\nexports.replaceWithSplit = replaceWithSplit;\r\nexports.mergeDict = mergeDict;\r\nexports.turnDict = turnDict;\r\nfunction setSplit(splitVal) {\r\n    split = splitVal;\r\n}\r\nfunction mergeDict(...args) {\r\n    var mergeValue = {};\r\n    for (var i in args) {\r\n        var arg = args[i];\r\n        for (var j in arg) {\r\n            mergeValue[j] = arg[j];\r\n        }\r\n    }\r\n    return mergeValue;\r\n}\r\nfunction turnDict(dict) {\r\n    var returnDict = {};\r\n    for (var i in dict) {\r\n        if (returnDict[dict[i]]) {\r\n            throw {\r\n                name: \"TypeError\",\r\n                message: `字典的键值对没有唯一对应关系:${returnDict[dict[i]]}:${dict[i]}与${i}:${dict[i]}冲突.`\r\n            };\r\n        }\r\n        else {\r\n            returnDict[dict[i]] = i;\r\n        }\r\n    }\r\n    return returnDict;\r\n}\r\nfunction replaceContent(content, dict) {\r\n    var patt = /[\\u4E00-\\u9FA5A-Za-z0-9_$-]+/g;\r\n    var match = content.match(patt);\r\n    var fail = [];\r\n    var success = [];\r\n    for (var i in match) {\r\n        let index = parseInt(i);\r\n        if (dict[match[index]]) {\r\n            content = content.replace(match[index], dict[match[index]]);\r\n            success.push(match[index]);\r\n        }\r\n        else {\r\n            fail.push(match[index]);\r\n        }\r\n    }\r\n    return {\r\n        content: content,\r\n        success: success,\r\n        fail: fail\r\n    };\r\n}\r\nfunction replaceWithSplit(content, dict) {\r\n    var strArray = content.split(split);\r\n    var str = \"\";\r\n    var objectArray = [];\r\n    var returnValue;\r\n    for (let i in strArray) {\r\n        if (parseInt(i) % 2 == 0) {\r\n            returnValue = replaceContent(strArray[i], dict);\r\n            str = str + returnValue.content;\r\n            objectArray.push(returnValue);\r\n        }\r\n        else {\r\n            str = str + strArray[i];\r\n            objectArray.push(strArray[i]);\r\n        }\r\n    }\r\n    return {\r\n        content: str,\r\n        returnArray: objectArray\r\n    };\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGliL3JlcGxhY2VyLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9yZXBsYWNlci50cz9lN2Y0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgc3BsaXQgPSBcIu+/pVwiO1xyXG5leHBvcnRzLnNldFNwbGl0ID0gc2V0U3BsaXQ7XHJcbmV4cG9ydHMucmVwbGFjZUNvbnRlbnQgPSByZXBsYWNlQ29udGVudDtcclxuZXhwb3J0cy5yZXBsYWNlV2l0aFNwbGl0ID0gcmVwbGFjZVdpdGhTcGxpdDtcclxuZXhwb3J0cy5tZXJnZURpY3QgPSBtZXJnZURpY3Q7XHJcbmV4cG9ydHMudHVybkRpY3QgPSB0dXJuRGljdDtcclxuZnVuY3Rpb24gc2V0U3BsaXQoc3BsaXRWYWwpIHtcclxuICAgIHNwbGl0ID0gc3BsaXRWYWw7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VEaWN0KC4uLmFyZ3MpIHtcclxuICAgIHZhciBtZXJnZVZhbHVlID0ge307XHJcbiAgICBmb3IgKHZhciBpIGluIGFyZ3MpIHtcclxuICAgICAgICB2YXIgYXJnID0gYXJnc1tpXTtcclxuICAgICAgICBmb3IgKHZhciBqIGluIGFyZykge1xyXG4gICAgICAgICAgICBtZXJnZVZhbHVlW2pdID0gYXJnW2pdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtZXJnZVZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIHR1cm5EaWN0KGRpY3QpIHtcclxuICAgIHZhciByZXR1cm5EaWN0ID0ge307XHJcbiAgICBmb3IgKHZhciBpIGluIGRpY3QpIHtcclxuICAgICAgICBpZiAocmV0dXJuRGljdFtkaWN0W2ldXSkge1xyXG4gICAgICAgICAgICB0aHJvdyB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBcIlR5cGVFcnJvclwiLFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYOWtl+WFuOeahOmUruWAvOWvueayoeacieWUr+S4gOWvueW6lOWFs+ezuzoke3JldHVybkRpY3RbZGljdFtpXV19OiR7ZGljdFtpXX3kuI4ke2l9OiR7ZGljdFtpXX3lhrLnqoEuYFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuRGljdFtkaWN0W2ldXSA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldHVybkRpY3Q7XHJcbn1cclxuZnVuY3Rpb24gcmVwbGFjZUNvbnRlbnQoY29udGVudCwgZGljdCkge1xyXG4gICAgdmFyIHBhdHQgPSAvW1xcdTRFMDAtXFx1OUZBNUEtWmEtejAtOV8kLV0rL2c7XHJcbiAgICB2YXIgbWF0Y2ggPSBjb250ZW50Lm1hdGNoKHBhdHQpO1xyXG4gICAgdmFyIGZhaWwgPSBbXTtcclxuICAgIHZhciBzdWNjZXNzID0gW107XHJcbiAgICBmb3IgKHZhciBpIGluIG1hdGNoKSB7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gcGFyc2VJbnQoaSk7XHJcbiAgICAgICAgaWYgKGRpY3RbbWF0Y2hbaW5kZXhdXSkge1xyXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKG1hdGNoW2luZGV4XSwgZGljdFttYXRjaFtpbmRleF1dKTtcclxuICAgICAgICAgICAgc3VjY2Vzcy5wdXNoKG1hdGNoW2luZGV4XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmYWlsLnB1c2gobWF0Y2hbaW5kZXhdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXHJcbiAgICAgICAgc3VjY2Vzczogc3VjY2VzcyxcclxuICAgICAgICBmYWlsOiBmYWlsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHJlcGxhY2VXaXRoU3BsaXQoY29udGVudCwgZGljdCkge1xyXG4gICAgdmFyIHN0ckFycmF5ID0gY29udGVudC5zcGxpdChzcGxpdCk7XHJcbiAgICB2YXIgc3RyID0gXCJcIjtcclxuICAgIHZhciBvYmplY3RBcnJheSA9IFtdO1xyXG4gICAgdmFyIHJldHVyblZhbHVlO1xyXG4gICAgZm9yIChsZXQgaSBpbiBzdHJBcnJheSkge1xyXG4gICAgICAgIGlmIChwYXJzZUludChpKSAlIDIgPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHJlcGxhY2VDb250ZW50KHN0ckFycmF5W2ldLCBkaWN0KTtcclxuICAgICAgICAgICAgc3RyID0gc3RyICsgcmV0dXJuVmFsdWUuY29udGVudDtcclxuICAgICAgICAgICAgb2JqZWN0QXJyYXkucHVzaChyZXR1cm5WYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdHIgPSBzdHIgKyBzdHJBcnJheVtpXTtcclxuICAgICAgICAgICAgb2JqZWN0QXJyYXkucHVzaChzdHJBcnJheVtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjb250ZW50OiBzdHIsXHJcbiAgICAgICAgcmV0dXJuQXJyYXk6IG9iamVjdEFycmF5XHJcbiAgICB9O1xyXG59XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/lib/replacer.ts\n");

/***/ }),

/***/ "./src/lib/utils.ts":
/*!**************************!*\
  !*** ./src/lib/utils.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar nodefetch = __webpack_require__(/*! node-fetch */ \"./node_modules/node-fetch/lib/index.mjs\");\r\nvar fs = __webpack_require__(/*! fs */ \"fs\");\r\nexports.readWithWeb = readWithWeb;\r\nexports.readWithWebAndRedirect = readWithWebAndRedirect;\r\nexports.downloadWithWeb = downloadWithWeb;\r\nexports.downloadWithWebAndRedirect = downloadWithWebAndRedirect;\r\nexports.readWithFile = readWithFile;\r\nfunction downloadWithWeb(path, url) {\r\n    if (!url) {\r\n        url = \"https://api.github.com/repos/Orangex4/Orangex/releases/latest\";\r\n    }\r\n    if (!path) {\r\n        path = \"./map/dict.json\";\r\n    }\r\n    nodefetch(url, {\r\n        method: 'GET',\r\n        headers: { 'Content-Type': 'application/octet-stream' },\r\n    }).then((res) => res.buffer()).then((_buffer) => {\r\n        fs.writeFile(path, _buffer, \"binary\", function (err) {\r\n            console.log(err || path);\r\n        });\r\n    });\r\n}\r\nfunction downloadWithWebAndRedirect(path, url) {\r\n    if (!url) {\r\n        url = \"https://api.github.com/repos/Orangex4/Orangex/releases/latest\";\r\n    }\r\n    readWithWeb((html) => {\r\n        var jsonObject = JSON.parse(html);\r\n        var fileUrl = jsonObject.assets[0].browser_download_url;\r\n        downloadWithWeb(path, fileUrl);\r\n    }, url);\r\n}\r\nfunction readWithWeb(callback, url) {\r\n    if (!url) {\r\n        url = \"https://api.github.com/repos/Orangex4/Orangex/releases/latest\";\r\n    }\r\n    nodefetch(url, {\r\n        method: 'GET',\r\n        headers: { 'Content-Type': 'application/octet-stream' },\r\n    }).then((res) => res.buffer()).then((_buffer) => {\r\n        callback(_buffer.toString(\"utf8\"));\r\n    });\r\n}\r\nfunction readWithWebAndRedirect(callback, url) {\r\n    if (!url) {\r\n        url = \"https://api.github.com/repos/Orangex4/Orangex/releases/latest\";\r\n    }\r\n    readWithWeb((html) => {\r\n        var jsonObject = JSON.parse(html);\r\n        var fileUrl = jsonObject.assets[0].browser_download_url;\r\n        readWithWeb(callback, fileUrl);\r\n    }, url);\r\n}\r\nfunction readWithFile(callback, path) {\r\n    var data = \"\";\r\n    if (!path) {\r\n        path = \"D:\\\\project\\\\Orangex\\\\map\\\\dict.json\";\r\n    }\r\n    var readerStream = fs.createReadStream(path);\r\n    readerStream.setEncoding('UTF8');\r\n    readerStream.on('data', function (chunk) {\r\n        data += chunk;\r\n    });\r\n    readerStream.on('end', function () {\r\n        callback(data);\r\n    });\r\n    readerStream.on('error', function (err) {\r\n        console.log(err.stack);\r\n    });\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGliL3V0aWxzLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi91dGlscy50cz83OWRlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgbm9kZWZldGNoID0gcmVxdWlyZShcIm5vZGUtZmV0Y2hcIik7XHJcbnZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcclxuZXhwb3J0cy5yZWFkV2l0aFdlYiA9IHJlYWRXaXRoV2ViO1xyXG5leHBvcnRzLnJlYWRXaXRoV2ViQW5kUmVkaXJlY3QgPSByZWFkV2l0aFdlYkFuZFJlZGlyZWN0O1xyXG5leHBvcnRzLmRvd25sb2FkV2l0aFdlYiA9IGRvd25sb2FkV2l0aFdlYjtcclxuZXhwb3J0cy5kb3dubG9hZFdpdGhXZWJBbmRSZWRpcmVjdCA9IGRvd25sb2FkV2l0aFdlYkFuZFJlZGlyZWN0O1xyXG5leHBvcnRzLnJlYWRXaXRoRmlsZSA9IHJlYWRXaXRoRmlsZTtcclxuZnVuY3Rpb24gZG93bmxvYWRXaXRoV2ViKHBhdGgsIHVybCkge1xyXG4gICAgaWYgKCF1cmwpIHtcclxuICAgICAgICB1cmwgPSBcImh0dHBzOi8vYXBpLmdpdGh1Yi5jb20vcmVwb3MvT3JhbmdleDQvT3JhbmdleC9yZWxlYXNlcy9sYXRlc3RcIjtcclxuICAgIH1cclxuICAgIGlmICghcGF0aCkge1xyXG4gICAgICAgIHBhdGggPSBcIi4vbWFwL2RpY3QuanNvblwiO1xyXG4gICAgfVxyXG4gICAgbm9kZWZldGNoKHVybCwge1xyXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScgfSxcclxuICAgIH0pLnRoZW4oKHJlcykgPT4gcmVzLmJ1ZmZlcigpKS50aGVuKChfYnVmZmVyKSA9PiB7XHJcbiAgICAgICAgZnMud3JpdGVGaWxlKHBhdGgsIF9idWZmZXIsIFwiYmluYXJ5XCIsIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyIHx8IHBhdGgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZG93bmxvYWRXaXRoV2ViQW5kUmVkaXJlY3QocGF0aCwgdXJsKSB7XHJcbiAgICBpZiAoIXVybCkge1xyXG4gICAgICAgIHVybCA9IFwiaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS9yZXBvcy9PcmFuZ2V4NC9PcmFuZ2V4L3JlbGVhc2VzL2xhdGVzdFwiO1xyXG4gICAgfVxyXG4gICAgcmVhZFdpdGhXZWIoKGh0bWwpID0+IHtcclxuICAgICAgICB2YXIganNvbk9iamVjdCA9IEpTT04ucGFyc2UoaHRtbCk7XHJcbiAgICAgICAgdmFyIGZpbGVVcmwgPSBqc29uT2JqZWN0LmFzc2V0c1swXS5icm93c2VyX2Rvd25sb2FkX3VybDtcclxuICAgICAgICBkb3dubG9hZFdpdGhXZWIocGF0aCwgZmlsZVVybCk7XHJcbiAgICB9LCB1cmwpO1xyXG59XHJcbmZ1bmN0aW9uIHJlYWRXaXRoV2ViKGNhbGxiYWNrLCB1cmwpIHtcclxuICAgIGlmICghdXJsKSB7XHJcbiAgICAgICAgdXJsID0gXCJodHRwczovL2FwaS5naXRodWIuY29tL3JlcG9zL09yYW5nZXg0L09yYW5nZXgvcmVsZWFzZXMvbGF0ZXN0XCI7XHJcbiAgICB9XHJcbiAgICBub2RlZmV0Y2godXJsLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyB9LFxyXG4gICAgfSkudGhlbigocmVzKSA9PiByZXMuYnVmZmVyKCkpLnRoZW4oKF9idWZmZXIpID0+IHtcclxuICAgICAgICBjYWxsYmFjayhfYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiKSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZWFkV2l0aFdlYkFuZFJlZGlyZWN0KGNhbGxiYWNrLCB1cmwpIHtcclxuICAgIGlmICghdXJsKSB7XHJcbiAgICAgICAgdXJsID0gXCJodHRwczovL2FwaS5naXRodWIuY29tL3JlcG9zL09yYW5nZXg0L09yYW5nZXgvcmVsZWFzZXMvbGF0ZXN0XCI7XHJcbiAgICB9XHJcbiAgICByZWFkV2l0aFdlYigoaHRtbCkgPT4ge1xyXG4gICAgICAgIHZhciBqc29uT2JqZWN0ID0gSlNPTi5wYXJzZShodG1sKTtcclxuICAgICAgICB2YXIgZmlsZVVybCA9IGpzb25PYmplY3QuYXNzZXRzWzBdLmJyb3dzZXJfZG93bmxvYWRfdXJsO1xyXG4gICAgICAgIHJlYWRXaXRoV2ViKGNhbGxiYWNrLCBmaWxlVXJsKTtcclxuICAgIH0sIHVybCk7XHJcbn1cclxuZnVuY3Rpb24gcmVhZFdpdGhGaWxlKGNhbGxiYWNrLCBwYXRoKSB7XHJcbiAgICB2YXIgZGF0YSA9IFwiXCI7XHJcbiAgICBpZiAoIXBhdGgpIHtcclxuICAgICAgICBwYXRoID0gXCJEOlxcXFxwcm9qZWN0XFxcXE9yYW5nZXhcXFxcbWFwXFxcXGRpY3QuanNvblwiO1xyXG4gICAgfVxyXG4gICAgdmFyIHJlYWRlclN0cmVhbSA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0ocGF0aCk7XHJcbiAgICByZWFkZXJTdHJlYW0uc2V0RW5jb2RpbmcoJ1VURjgnKTtcclxuICAgIHJlYWRlclN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xyXG4gICAgICAgIGRhdGEgKz0gY2h1bms7XHJcbiAgICB9KTtcclxuICAgIHJlYWRlclN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNhbGxiYWNrKGRhdGEpO1xyXG4gICAgfSk7XHJcbiAgICByZWFkZXJTdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGVyci5zdGFjayk7XHJcbiAgICB9KTtcclxufVxyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/lib/utils.ts\n");

/***/ }),

/***/ "./src/test/main.test.ts":
/*!*******************************!*\
  !*** ./src/test/main.test.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar replacer = __webpack_require__(/*! ../lib/replacer */ \"./src/lib/replacer.ts\");\r\nvar utils = __webpack_require__(/*! ../lib/utils */ \"./src/lib/utils.ts\");\r\nvar str = \"jsx js  default if  ddd ￥中文注释￥ 1数字-Head $\";\r\n{\r\n}\r\nutils.readWithFile(testFunc);\r\nvar testDict = { a: \"1\", b: \"2\", c: \"3\", d: \"5\", e: \"6\" };\r\nconsole.log(\"Merge:\");\r\nconsole.log(replacer.mergeDict({ a: \"1\", b: \"2\", c: \"3\" }, { c: \"4\", d: \"5\", e: \"6\" }));\r\nconsole.log(\"Turn:\");\r\nconsole.log(replacer.turnDict(testDict));\r\nfunction testFunc(dict) {\r\n    replacer.setSplit(\"￥\");\r\n    var dictionary = JSON.parse(dict);\r\n    var mergeDict = replacer.mergeDict(dictionary.common, dictionary.computer);\r\n    var returnObject = replacer.replaceWithSplit(str, mergeDict);\r\n    console.log(\"All:\");\r\n    console.log(returnObject);\r\n    console.log(\"Content:\");\r\n    console.log(returnObject.content);\r\n    console.log(\"Translater:\");\r\n    console.log(replacer.replaceWithSplit(returnObject.content, replacer.turnDict(mergeDict)).content);\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdGVzdC9tYWluLnRlc3QudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdGVzdC9tYWluLnRlc3QudHM/OTU1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxudmFyIHJlcGxhY2VyID0gcmVxdWlyZSgnLi4vbGliL3JlcGxhY2VyJyk7XHJcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL2xpYi91dGlscycpO1xyXG52YXIgc3RyID0gXCJqc3gganMgIGRlZmF1bHQgaWYgIGRkZCDvv6XkuK3mlofms6jph4rvv6UgMeaVsOWtly1IZWFkICRcIjtcclxue1xyXG59XHJcbnV0aWxzLnJlYWRXaXRoRmlsZSh0ZXN0RnVuYyk7XHJcbnZhciB0ZXN0RGljdCA9IHsgYTogXCIxXCIsIGI6IFwiMlwiLCBjOiBcIjNcIiwgZDogXCI1XCIsIGU6IFwiNlwiIH07XHJcbmNvbnNvbGUubG9nKFwiTWVyZ2U6XCIpO1xyXG5jb25zb2xlLmxvZyhyZXBsYWNlci5tZXJnZURpY3QoeyBhOiBcIjFcIiwgYjogXCIyXCIsIGM6IFwiM1wiIH0sIHsgYzogXCI0XCIsIGQ6IFwiNVwiLCBlOiBcIjZcIiB9KSk7XHJcbmNvbnNvbGUubG9nKFwiVHVybjpcIik7XHJcbmNvbnNvbGUubG9nKHJlcGxhY2VyLnR1cm5EaWN0KHRlc3REaWN0KSk7XHJcbmZ1bmN0aW9uIHRlc3RGdW5jKGRpY3QpIHtcclxuICAgIHJlcGxhY2VyLnNldFNwbGl0KFwi77+lXCIpO1xyXG4gICAgdmFyIGRpY3Rpb25hcnkgPSBKU09OLnBhcnNlKGRpY3QpO1xyXG4gICAgdmFyIG1lcmdlRGljdCA9IHJlcGxhY2VyLm1lcmdlRGljdChkaWN0aW9uYXJ5LmNvbW1vbiwgZGljdGlvbmFyeS5jb21wdXRlcik7XHJcbiAgICB2YXIgcmV0dXJuT2JqZWN0ID0gcmVwbGFjZXIucmVwbGFjZVdpdGhTcGxpdChzdHIsIG1lcmdlRGljdCk7XHJcbiAgICBjb25zb2xlLmxvZyhcIkFsbDpcIik7XHJcbiAgICBjb25zb2xlLmxvZyhyZXR1cm5PYmplY3QpO1xyXG4gICAgY29uc29sZS5sb2coXCJDb250ZW50OlwiKTtcclxuICAgIGNvbnNvbGUubG9nKHJldHVybk9iamVjdC5jb250ZW50KTtcclxuICAgIGNvbnNvbGUubG9nKFwiVHJhbnNsYXRlcjpcIik7XHJcbiAgICBjb25zb2xlLmxvZyhyZXBsYWNlci5yZXBsYWNlV2l0aFNwbGl0KHJldHVybk9iamVjdC5jb250ZW50LCByZXBsYWNlci50dXJuRGljdChtZXJnZURpY3QpKS5jb250ZW50KTtcclxufVxyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/test/main.test.ts\n");

/***/ }),

/***/ 0:
/*!****************************!*\
  !*** multi ./src/index.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./src/index.ts */"./src/index.ts");


/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("zlib");

/***/ })

/******/ });